<?xml version="1.0" encoding="UTF-8"?>
<pythonPanelDocument>
  <!-- This file contains definitions of Python interfaces and the
 interfaces menu.  It should not be hand-edited when it is being
 used by the application.  Note, that two definitions of the
 same interface or of the interfaces menu are not allowed
 in a single file. -->
  <interface name="Lean Node Editor" label="Lean Node Editor" icon="MISC_python" showNetworkNavigationBar="false" help_url="">
    <script><![CDATA["""
Houdini Node Editor Python Pane with Lean 4 JSON Format
To use: In Houdini, create a new Python Panel and paste this code

Features:
- Lean 4 JSON format with builtin/struct port types
- Full NodeType stored in each node
- Implicit connections (invisible by default, toggleable)
- Structural type matching with wildcard support
- Custom per-node port types
- Structured node editing panel
"""

import json
import hou
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGraphicsView, 
                               QGraphicsScene, QGraphicsItem, QGraphicsRectItem,
                               QGraphicsTextItem, QPushButton, QFileDialog, 
                               QGraphicsPathItem, QInputDialog, QLineEdit, QMenu, 
                               QLabel, QFrame, QTextEdit, QSplitter, QCheckBox,
                               QScrollArea, QGridLayout)
from PySide6.QtCore import Qt, QRectF, QPointF, QTimer
from PySide6.QtGui import QPen, QBrush, QColor, QPainterPath, QFont, QPainter, QPainterPathStroker, QLinearGradient
from PySide6.QtWidgets import QStyle

# Houdini color scheme
HOUDINI_BG = QColor(58, 58, 58)
HOUDINI_BG_DARK = QColor(38, 38, 38)
HOUDINI_BG_LIGHT = QColor(68, 68, 68)
HOUDINI_NODE_BG = QColor(48, 48, 48)
HOUDINI_NODE_BORDER = QColor(28, 28, 28)
HOUDINI_NODE_SELECTED = QColor(248, 156, 40)
HOUDINI_TEXT = QColor(220, 220, 220)
HOUDINI_TEXT_DIM = QColor(150, 150, 150)
HOUDINI_GRID_FINE = QColor(50, 50, 50)
HOUDINI_GRID_THICK = QColor(60, 60, 60)
HOUDINI_ERROR = QColor(220, 60, 60)
HOUDINI_IMPLICIT = QColor(120, 120, 120, 200)


def get_type_color(type_name, registry=None, node_type=None):
    """Get color for a port type"""
    colors = {
        'Float': QColor(120, 220, 120),
        'Vector3': QColor(100, 180, 255),
        'Particle': QColor(255, 160, 100),
        'Character': QColor(200, 120, 200),
        'Type': QColor(180, 120, 255),
        'Int': QColor(120, 255, 180),
        'String': QColor(255, 180, 120),
        '?_': QColor(160, 160, 160),
    }
    
    if type_name in colors:
        return colors[type_name]
    else:
        if registry and _type_contains_wildcards(type_name, registry, node_type):
            return QColor(160, 160, 160)
        else:
            return QColor(255, 220, 100)


def _type_contains_wildcards(type_name, registry, node_type):
    """Check if a type or any of its subports contain wildcards"""
    if type_name == "?_":
        return True
    
    port_type = registry.get_port_type(type_name, node_type)
    if not port_type or not port_type.subports:
        return False
    
    for subport_name, subport_type in port_type.subports:
        if _type_contains_wildcards(subport_type, registry, node_type):
            return True
    
    return False


class PortType:
    def __init__(self, name, type_name, subports=None):
        self.name = name
        self.type_name = type_name
        self.subports = subports or []


class NodeType:
    def __init__(self, name, lean_constant, inputs, outputs, expose_implicit_args=False, custom_port_types=None):
        self.name = name
        self.lean_constant = lean_constant
        self.expose_implicit_args = expose_implicit_args
        self.inputs = inputs
        self.outputs = outputs
        self.custom_port_types = custom_port_types or {}


class NodeTypeRegistry:
    def __init__(self):
        self.node_types = {}
        self.port_types = {}
    
    def load_from_json(self, json_data):
        data = json.loads(json_data) if isinstance(json_data, str) else json_data
        
        for port_type_data in data.get('portTypes', []):
            port_type = self._parse_port_type(port_type_data)
            if port_type:
                self.port_types[port_type.type_name] = port_type
        
        for node_def in data.get('nodeTypes', []):
            node_type = self._parse_node_type(node_def)
            if node_type:
                self.node_types[node_type.name] = node_type
    
    def _parse_port_type(self, port_data):
        """Parse PortType from Lean JSON format (builtin or struct)"""
        if 'builtin' in port_data:
            builtin = port_data['builtin']
            return PortType(builtin['name'], builtin['type'], [])
        elif 'struct' in port_data:
            struct = port_data['struct']
            subports = []
            for sp_data in struct.get('subports', []):
                sp = self._parse_port_type(sp_data)
                if sp:
                    subports.append((sp.name, sp.type_name))
            return PortType(struct['name'], struct['type'], subports)
        return None
    
    def _parse_node_type(self, node_def):
        """Parse NodeType from Lean JSON format"""
        custom_port_types = {}
        
        def extract_custom_types(port_data):
            if 'struct' in port_data:
                struct = port_data['struct']
                type_name = struct['type']
                subports = []
                
                for sp_data in struct.get('subports', []):
                    sp = self._parse_port_type(sp_data)
                    if sp:
                        subports.append((sp.name, sp.type_name))
                        extract_custom_types(sp_data)
                
                if type_name not in self.port_types:
                    custom_port_types[type_name] = PortType(struct['name'], type_name, subports)
        
        inputs = []
        for inp_data in node_def.get('inputs', []):
            inp = self._parse_port_type(inp_data)
            if inp:
                inputs.append((inp.name, inp.type_name))
                extract_custom_types(inp_data)
        
        outputs = []
        for out_data in node_def.get('outputs', []):
            out = self._parse_port_type(out_data)
            if out:
                outputs.append((out.name, out.type_name))
                extract_custom_types(out_data)
        
        return NodeType(
            node_def['name'],
            node_def.get('leanConstant', ''),
            inputs,
            outputs,
            node_def.get('exposeImplicitArgs', False),
            custom_port_types
        )
    
    def get_port_type(self, type_name, node_type=None):
        """Get port type, checking node-specific custom types first"""
        if node_type and type_name in node_type.custom_port_types:
            return node_type.custom_port_types[type_name]
        return self.port_types.get(type_name)
    
    def get_node_type(self, type_name):
        return self.node_types.get(type_name)


class SubportWidget(QGraphicsItem):
    PORT_RADIUS = 5
    SUBPORT_SPACING = 22
    
    def __init__(self, name, type_name, is_input, parent_port, registry, node_type=None):
        super().__init__()
        self.name = name
        self.type_name = type_name
        self.is_input = is_input
        self.parent_port = parent_port
        self.node = parent_port.node
        self.registry = registry
        self.node_type = node_type or (parent_port.node_type if hasattr(parent_port, 'node_type') else None)
        self.connections = []
        self.hover_active = False
        
        self.subport_widgets = []
        self.expanded = False
        self.expansion_widget = None
        
        port_type = registry.get_port_type(type_name, self.node_type)
        self.subport_defs = []
        if port_type and port_type.subports:
            self.subport_defs = port_type.subports
        
        self.allow_structural_matching = True
        
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
    
    def boundingRect(self):
        return QRectF(-self.PORT_RADIUS, -self.PORT_RADIUS, 
                     self.PORT_RADIUS * 2, self.PORT_RADIUS * 2)
    
    def shape(self):
        path = QPainterPath()
        radius = self.PORT_RADIUS + 5
        path.addEllipse(QPointF(0, 0), radius, radius)
        return path
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        color = get_type_color(self.type_name, self.registry, self.node_type)
        
        if self.has_connection():
            painter.setBrush(QBrush(color))
        else:
            painter.setBrush(QBrush(color.darker(180)))
        
        border_width = 2.5 if self.hover_active else 1.5
        painter.setPen(QPen(color.darker(120), border_width))
        painter.drawEllipse(self.boundingRect())
    
    def get_full_path(self):
        return f"{self.parent_port.get_full_path()}.{self.name}"
    
    def get_index_path(self):
        """Get the index path [port_idx, subport_idx, ...]"""
        path = []
        current = self
        while hasattr(current, 'parent_port') and current.parent_port:
            parent = current.parent_port
            if hasattr(parent, 'subport_widgets'):
                idx = parent.subport_widgets.index(current) if current in parent.subport_widgets else -1
                path.insert(0, idx)
            current = parent
        
        if hasattr(current, 'node'):
            ports = current.node.input_ports if current.is_input else current.node.output_ports
            if current in ports:
                path.insert(0, ports.index(current))
        
        return path
    
    def has_connection(self):
        if self.connections:
            return True
        for subport in self.subport_widgets:
            if subport.has_connection():
                return True
        return False
    
    def is_connectable_to(self, other_port):
        if self.is_input == other_port.is_input:
            return False
        if self.node == other_port.node:
            return False
        
        if not self.types_are_compatible(other_port):
            return False
        
        input_port = self if self.is_input else other_port
        if input_port.is_occupied():
            return False
        return True
    
    def types_are_compatible(self, other_port):
        """Check if types are compatible"""
        if self.allow_structural_matching:
            return self._types_structurally_match(other_port)
        else:
            return self.type_name == other_port.type_name
    
    def _types_structurally_match(self, other_port):
        """Check if two ports have matching structure"""
        if self.type_name == "?_" or other_port.type_name == "?_":
            return True
        
        if self.type_name == other_port.type_name:
            return True
        
        my_port_type = self.registry.get_port_type(self.type_name, self.node_type)
        other_port_type = self.registry.get_port_type(other_port.type_name, 
                                                       other_port.node_type if hasattr(other_port, 'node_type') else None)
        
        if not my_port_type or not my_port_type.subports:
            if not other_port_type or not other_port_type.subports:
                return self.type_name == other_port.type_name
            return False
        
        if not other_port_type or not other_port_type.subports:
            return False
        
        my_subports = my_port_type.subports
        other_subports = other_port_type.subports
        
        if len(my_subports) != len(other_subports):
            return False
        
        my_has_wildcards = self._structure_has_wildcards(my_subports)
        other_has_wildcards = self._structure_has_wildcards(other_subports)
        
        for (my_name, my_type), (other_name, other_type) in zip(my_subports, other_subports):
            if not (my_has_wildcards or other_has_wildcards):
                if my_name != other_name:
                    return False
            
            temp_my_subport = SubportWidget(my_name, my_type, self.is_input, self, self.registry, self.node_type)
            temp_other_subport = SubportWidget(other_name, other_type, other_port.is_input, other_port, 
                                               self.registry, other_port.node_type if hasattr(other_port, 'node_type') else None)
            
            if not temp_my_subport._types_structurally_match(temp_other_subport):
                return False
        
        return True
    
    def _structure_has_wildcards(self, subports):
        """Check if a structure contains any wildcard types"""
        for name, type_name in subports:
            if type_name == "?_":
                return True
            port_type = self.registry.get_port_type(type_name, self.node_type)
            if port_type and port_type.subports:
                if self._structure_has_wildcards(port_type.subports):
                    return True
        return False
    
    def is_occupied(self):
        # Check only non-implicit connections
        if any(not conn.is_implicit for conn in self.connections):
            return True
        current = self.parent_port
        while current:
            if any(not conn.is_implicit for conn in current.connections):
                return True
            current = current.parent_port if hasattr(current, 'parent_port') else None
        return self._has_connected_descendant()
    
    def _has_connected_descendant(self):
        for subport in self.subport_widgets:
            if any(not conn.is_implicit for conn in subport.connections) or subport._has_connected_descendant():
                return True
        return False
    
    def get_scene_pos(self):
        return self.scenePos()
    
    def expand(self):
        if not self.subport_defs or self.expanded:
            return
        
        self.expanded = True
        original_scene_pos = self.get_scene_pos()
        
        self.subport_widgets = []
        for subport_name, subport_type in self.subport_defs:
            subport = SubportWidget(subport_name, subport_type, self.is_input, self, self.registry, self.node_type)
            subport.allow_structural_matching = self.allow_structural_matching
            self.subport_widgets.append(subport)
        
        self.expansion_widget = SubportExpansion(self, self.subport_widgets, self.is_input)
        self.expansion_widget.setParentItem(self.node)
        
        node_pos = self.node.mapFromItem(self, 0, 0)
        if self.is_input:
            self.expansion_widget.setPos(node_pos.x() - 2*SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        else:
            self.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        
        self._update_parent_expansions()
        
        if self.node:
            self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def _update_parent_expansions(self):
        current = self.parent_port
        while current:
            if hasattr(current, 'expansion_widget') and current.expansion_widget:
                current.expansion_widget._update_subport_positions()
            if hasattr(current, 'parent_port'):
                current = current.parent_port
            else:
                break
    
    def collapse(self):
        if not self.expanded:
            return
        
        if self.node and self.node.scene():
            view = self.node.scene().views()[0] if self.node.scene().views() else None
            if view and hasattr(view, '_is_port_locked') and view._is_port_locked(self):
                return
        
        has_connections = any(subport.has_connection() for subport in self.subport_widgets)
        
        if not has_connections:
            original_scene_pos = self.get_scene_pos()
            self.expanded = False
            
            for subport in self.subport_widgets[:]:
                if subport.expanded:
                    subport.collapse()
            
            if self.expansion_widget:
                scene = self.scene()
                if scene and self.expansion_widget.scene() == scene:
                    scene.removeItem(self.expansion_widget)
                self.expansion_widget = None
            
            self.subport_widgets = []
            self._update_parent_expansions()
            
            if self.node:
                self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def hoverEnterEvent(self, event):
        self.hover_active = True
        self.update()
        if self.is_input and self.is_occupied():
            super().hoverEnterEvent(event)
            return
        if self.subport_defs and not self.expanded:
            self.expand()
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        self.hover_active = False
        self.update()
        QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.hover_active:
            return
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return
        if self._is_any_expansion_hovered():
            return
        self.collapse()
    
    def _is_any_expansion_hovered(self):
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return True
        for subport in self.subport_widgets:
            if subport.hover_active:
                return True
            if subport._is_any_expansion_hovered():
                return True
        return False


class PortWidget(QGraphicsItem):
    PORT_RADIUS = 6
    SUBPORT_SPACING = 22
    
    def __init__(self, name, type_name, registry, is_input, parent_port=None, node=None, node_type=None):
        super().__init__()
        self.name = name
        self.type_name = type_name
        self.registry = registry
        self.is_input = is_input
        self.parent_port = parent_port
        self.node = node
        self.node_type = node_type
        self.subport_widgets = []
        self.expanded = False
        self.expansion_widget = None
        self.connections = []
        self.hover_active = False
        
        port_type = registry.get_port_type(type_name, self.node_type)
        self.subport_defs = []
        if port_type and port_type.subports:
            self.subport_defs = port_type.subports
        
        self.allow_structural_matching = True
        
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
    
    def boundingRect(self):
        return QRectF(-self.PORT_RADIUS, -self.PORT_RADIUS, 
                     self.PORT_RADIUS * 2, self.PORT_RADIUS * 2)
    
    def shape(self):
        path = QPainterPath()
        radius = self.PORT_RADIUS + 5
        path.addEllipse(QPointF(0, 0), radius, radius)
        return path
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        color = get_type_color(self.type_name, self.registry, self.node_type)
        
        if self.has_connection():
            painter.setBrush(QBrush(color))
        else:
            painter.setBrush(QBrush(color.darker(180)))
        
        border_width = 2.5 if self.hover_active else 1.5
        painter.setPen(QPen(color.darker(120), border_width))
        painter.drawEllipse(self.boundingRect())
    
    def get_full_path(self):
        if self.parent_port:
            return f"{self.parent_port.get_full_path()}.{self.name}"
        return self.name
    
    def get_index_path(self):
        """Get the index path [port_idx, subport_idx, ...]"""
        ports = self.node.input_ports if self.is_input else self.node.output_ports
        if self in ports:
            return [ports.index(self)]
        return []
    
    def has_connection(self):
        if self.connections:
            return True
        for subport in self.subport_widgets:
            if subport.has_connection():
                return True
        return False
    
    def is_connectable_to(self, other_port):
        if self.is_input == other_port.is_input:
            return False
        if self.node == other_port.node:
            return False
        
        if not self.types_are_compatible(other_port):
            return False
        
        input_port = self if self.is_input else other_port
        if input_port.is_occupied():
            return False
        return True
    
    def types_are_compatible(self, other_port):
        """Check if types are compatible"""
        if self.allow_structural_matching:
            return self._types_structurally_match(other_port)
        else:
            return self.type_name == other_port.type_name
    
    def _types_structurally_match(self, other_port):
        """Check if two ports have matching structure"""
        if self.type_name == "?_" or other_port.type_name == "?_":
            return True
        
        if self.type_name == other_port.type_name:
            return True
        
        my_port_type = self.registry.get_port_type(self.type_name, self.node_type)
        other_port_type = self.registry.get_port_type(other_port.type_name, 
                                                       other_port.node_type if hasattr(other_port, 'node_type') else None)
        
        if not my_port_type or not my_port_type.subports:
            if not other_port_type or not other_port_type.subports:
                return self.type_name == other_port.type_name
            return False
        
        if not other_port_type or not other_port_type.subports:
            return False
        
        my_subports = my_port_type.subports
        other_subports = other_port_type.subports
        
        if len(my_subports) != len(other_subports):
            return False
        
        my_has_wildcards = self._structure_has_wildcards(my_subports)
        other_has_wildcards = self._structure_has_wildcards(other_subports)
        
        for (my_name, my_type), (other_name, other_type) in zip(my_subports, other_subports):
            if not (my_has_wildcards or other_has_wildcards):
                if my_name != other_name:
                    return False
            
            temp_my_port = PortWidget(my_name, my_type, self.registry, self.is_input, None, self.node, self.node_type)
            temp_other_port = PortWidget(other_name, other_type, self.registry, other_port.is_input, None, 
                                         other_port.node, other_port.node_type if hasattr(other_port, 'node_type') else None)
            
            if not temp_my_port._types_structurally_match(temp_other_port):
                return False
        
        return True
    
    def _structure_has_wildcards(self, subports):
        """Check if a structure contains any wildcard types"""
        for name, type_name in subports:
            if type_name == "?_":
                return True
            port_type = self.registry.get_port_type(type_name, self.node_type)
            if port_type and port_type.subports:
                if self._structure_has_wildcards(port_type.subports):
                    return True
        return False
    
    def is_occupied(self):
        # Check only non-implicit connections
        if any(not conn.is_implicit for conn in self.connections):
            return True
        current = self.parent_port
        while current:
            if any(not conn.is_implicit for conn in current.connections):
                return True
            current = current.parent_port
        return self._has_connected_descendant()
    
    def _has_connected_descendant(self):
        for subport in self.subport_widgets:
            if any(not conn.is_implicit for conn in subport.connections) or subport._has_connected_descendant():
                return True
        return False
    
    def get_scene_pos(self):
        return self.scenePos()
    
    def expand(self):
        if not self.subport_defs or self.expanded:
            return
        
        self.expanded = True
        original_scene_pos = self.get_scene_pos()
        
        self.subport_widgets = []
        for subport_name, subport_type in self.subport_defs:
            subport = SubportWidget(subport_name, subport_type, self.is_input, self, self.registry, self.node_type)
            subport.allow_structural_matching = self.allow_structural_matching
            self.subport_widgets.append(subport)
        
        self.expansion_widget = SubportExpansion(self, self.subport_widgets, self.is_input)
        self.expansion_widget.setParentItem(self.node)
        
        node_pos = self.node.mapFromItem(self, 0, 0)
        if self.is_input:
            self.expansion_widget.setPos(node_pos.x() - 2*SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        else:
            self.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        
        self._update_parent_expansions()
        
        if self.node:
            self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def _update_parent_expansions(self):
        current = self.parent_port
        while current:
            if hasattr(current, 'expansion_widget') and current.expansion_widget:
                current.expansion_widget._update_subport_positions()
            if hasattr(current, 'parent_port'):
                current = current.parent_port
            else:
                break
    
    def collapse(self):
        if not self.expanded:
            return
        
        if self.node and self.node.scene():
            view = self.node.scene().views()[0] if self.node.scene().views() else None
            if view and hasattr(view, '_is_port_locked') and view._is_port_locked(self):
                return
        
        has_connections = any(subport.has_connection() for subport in self.subport_widgets)
        
        if not has_connections:
            original_scene_pos = self.get_scene_pos()
            self.expanded = False
            
            for subport in self.subport_widgets[:]:
                if subport.expanded:
                    subport.collapse()
            
            if self.expansion_widget:
                scene = self.scene()
                if scene and self.expansion_widget.scene() == scene:
                    scene.removeItem(self.expansion_widget)
                self.expansion_widget = None
            
            self.subport_widgets = []
            
            if self.node:
                self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def hoverEnterEvent(self, event):
        self.hover_active = True
        self.update()
        if self.is_input and self.is_occupied():
            super().hoverEnterEvent(event)
            return
        if self.subport_defs and not self.expanded:
            self.expand()
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        self.hover_active = False
        self.update()
        QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.hover_active:
            return
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return
        if self._is_any_expansion_hovered():
            return
        self.collapse()
    
    def _is_any_expansion_hovered(self):
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return True
        for subport in self.subport_widgets:
            if subport.hover_active:
                return True
            if subport._is_any_expansion_hovered():
                return True
        return False


class SubportExpansion(QGraphicsRectItem):
    WIDTH = 12
    HOVER_MARGIN = 30
    
    def __init__(self, parent_port, subports, is_input):
        super().__init__()
        self.parent_port = parent_port
        self.subports = subports
        self.is_input = is_input
        self.labels = []
        
        self.setAcceptHoverEvents(True)
        
        height = len(subports) * PortWidget.SUBPORT_SPACING
        
        if is_input:
            self.setRect(0, 0, self.WIDTH, height)
        else:
            self.setRect(-self.WIDTH, 0, self.WIDTH, height)
        
        self.setBrush(QBrush(HOUDINI_BG_LIGHT))
        self.setPen(QPen(HOUDINI_NODE_BORDER, 1))
        
        self._update_subport_positions()
    
    def _update_subport_positions(self):
        current_y = PortWidget.SUBPORT_SPACING // 2
        
        for i, subport in enumerate(self.subports):
            if subport.parentItem() != self:
                subport.setParentItem(self)
            
            if self.is_input:
                subport.setPos(self.WIDTH, current_y)
            else:
                subport.setPos(0, current_y)
            
            if i < len(self.labels):
                label = self.labels[i]
            else:
                label = QGraphicsTextItem(subport.name, self)
                label.setDefaultTextColor(HOUDINI_TEXT)
                font = QFont("Arial", 9)
                label.setFont(font)
                self.labels.append(label)
            
            if self.is_input:
                label.setPos(self.WIDTH + PortWidget.PORT_RADIUS * 2 + 5, current_y - 8)
            else:
                label_width = label.boundingRect().width()
                label.setPos(-PortWidget.PORT_RADIUS * 2 - label_width - 5, current_y - 8)
            
            if subport.expanded and subport.expansion_widget:
                node_pos = subport.node.mapFromItem(subport, 0, 0)
                if self.is_input:
                    subport.expansion_widget.setPos(node_pos.x() - 2*SubportExpansion.WIDTH,
                                                   node_pos.y() + subport.PORT_RADIUS)
                else:
                    subport.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH,
                                                   node_pos.y() + subport.PORT_RADIUS)
            
            current_y += PortWidget.SUBPORT_SPACING
            if subport.expanded and subport.subport_widgets:
                current_y += self._calculate_subport_expansion_height(subport)
        
        new_height = current_y - PortWidget.SUBPORT_SPACING // 2
        
        if self.is_input:
            self.setRect(self.WIDTH, 0, self.WIDTH, new_height)
        else:
            self.setRect(-self.WIDTH, 0, self.WIDTH, new_height)
    
    def _calculate_subport_expansion_height(self, subport):
        if not subport.expanded or not subport.subport_widgets:
            return 0
        
        height = 0
        for nested in subport.subport_widgets:
            height += PortWidget.SUBPORT_SPACING
            if nested.expanded and nested.subport_widgets:
                height += self._calculate_subport_expansion_height(nested)
        return height
    
    def shape(self):
        path = QPainterPath()
        rect = self.rect()
        if self.is_input:
            expanded = QRectF(rect.x() - 5, 
                            rect.y() - 5, 
                            rect.width() + self.HOVER_MARGIN + 100,
                            rect.height() + 10)
        else:
            expanded = QRectF(rect.x() - self.HOVER_MARGIN - 100,
                            rect.y() - 5, 
                            rect.width() + self.HOVER_MARGIN + 100, 
                            rect.height() + 10)
        path.addRect(expanded)
        return path
    
    def hoverLeaveEvent(self, event):
        if not self.isUnderMouse():
            QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.isUnderMouse():
            return
        if self.parent_port.hover_active:
            return
        if self.parent_port._is_any_expansion_hovered():
            return
        self.parent_port.collapse()


class Connection(QGraphicsPathItem):
    def __init__(self, output_port, input_port, scene, output_index_path=None, input_index_path=None, is_implicit=False):
        super().__init__()
        self.output_port = output_port
        self.input_port = input_port
        self.output_node = output_port.node if output_port else None
        self.input_node = input_port.node if input_port else None
        self.is_implicit = is_implicit
        
        self.output_index_path = output_index_path or (output_port.get_index_path() if output_port else [])
        self.input_index_path = input_index_path or (input_port.get_index_path() if input_port else [])
        
        if self.output_node and output_port:
            self.output_rel_pos = output_port.get_scene_pos().y() - self.output_node.pos().y()
        else:
            self.output_rel_pos = 0
            
        if self.input_node and input_port:
            self.input_rel_pos = input_port.get_scene_pos().y() - self.input_node.pos().y()
        else:
            self.input_rel_pos = 0
        
        self.setFlag(QGraphicsItem.ItemIsSelectable, not is_implicit)
        self.setFlag(QGraphicsItem.ItemIsMovable, False)
        
        self.output_valid = output_port is not None
        self.input_valid = input_port is not None
        
        if is_implicit:
            self.normal_pen = QPen(HOUDINI_IMPLICIT, 2.0, Qt.DotLine)
        else:
            color = get_type_color(output_port.type_name, 
                                  output_port.registry if output_port else None,
                                  output_port.node_type if output_port and hasattr(output_port, 'node_type') else None) if output_port else HOUDINI_ERROR
            self.normal_pen = QPen(color, 2.5)
        
        self.selected_pen = QPen(HOUDINI_NODE_SELECTED, 3.5)
        self.invalid_pen = QPen(HOUDINI_ERROR, 2.5)
        self.shadow_pen = QPen(QColor(255, 255, 255, 180), 6.0)
        
        if output_port:
            output_port.connections.append(self)
        if input_port:
            input_port.connections.append(self)
        
        if output_port and isinstance(output_port, SubportWidget):
            self._expand_hierarchy(output_port)
        if input_port and isinstance(input_port, SubportWidget):
            self._expand_hierarchy(input_port)
        
        self.update_path()
    
    def is_valid(self):
        """Check if connection is valid"""
        if not (self.output_valid and self.input_valid):
            return False
        if self.output_port and self.input_port:
            return self.output_port.type_name == self.input_port.type_name
        return False
    
    def has_type_mismatch(self):
        """Check if both ends exist but types don't match"""
        return (self.output_valid and self.input_valid and 
                self.output_port.type_name != self.input_port.type_name)
    
    def boundingRect(self):
        if self.isSelected():
            return self.path().boundingRect().adjusted(-4, -4, 4, 4)
        return self.path().boundingRect()
    
    def shape(self):
        stroker = QPainterPathStroker()
        stroker.setWidth(12)
        stroker.setCapStyle(Qt.RoundCap)
        return stroker.createStroke(self.path())
    
    def _expand_hierarchy(self, port):
        if isinstance(port, SubportWidget):
            try:
                current = port.parent_port
                while current:
                    _ = current.scene()
                    if not current.expanded:
                        current.expand()
                    current = current.parent_port if hasattr(current, 'parent_port') else None
            except RuntimeError:
                pass
    
    def update_path(self):
        try:
            if self.output_port:
                start = self.output_port.get_scene_pos()
            elif self.output_node:
                start = QPointF(self.output_node.pos().x() + self.output_node.rect().width(),
                              self.output_node.pos().y() + self.output_rel_pos)
            else:
                return
            
            if self.input_port:
                end = self.input_port.get_scene_pos()
            elif self.input_node:
                end = QPointF(self.input_node.pos().x(),
                            self.input_node.pos().y() + self.input_rel_pos)
            else:
                return
            
            path = QPainterPath()
            path.moveTo(start)
            
            ctrl_offset = abs(end.x() - start.x()) * 0.5
            ctrl1 = QPointF(start.x() + ctrl_offset, start.y())
            ctrl2 = QPointF(end.x() - ctrl_offset, end.y())
            path.cubicTo(ctrl1, ctrl2, end)
            
            self.setPath(path)
        except RuntimeError:
            if self.scene():
                self.scene().removeItem(self)
    
    def remove(self):
        try:
            if self.output_port and self in self.output_port.connections:
                self.output_port.connections.remove(self)
        except (RuntimeError, AttributeError):
            pass
            
        try:
            if self.input_port and self in self.input_port.connections:
                self.input_port.connections.remove(self)
        except (RuntimeError, AttributeError):
            pass
        
        if not self.is_implicit:
            def try_collapse_hierarchy(port):
                try:
                    if isinstance(port, SubportWidget):
                        port.collapse()
                        if hasattr(port, 'parent_port') and port.parent_port:
                            try_collapse_hierarchy(port.parent_port)
                    elif isinstance(port, PortWidget):
                        port.collapse()
                except RuntimeError:
                    pass
            
            if self.output_port:
                try:
                    try_collapse_hierarchy(self.output_port)
                except (RuntimeError, AttributeError):
                    pass
                
            if self.input_port:
                try:
                    try_collapse_hierarchy(self.input_port)
                except (RuntimeError, AttributeError):
                    pass
        
        if self.scene():
            self.scene().removeItem(self)
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        
        if self.is_implicit:
            painter.setPen(self.normal_pen)
            painter.drawPath(self.path())
            return
        
        if self.isSelected():
            painter.setPen(self.shadow_pen)
            painter.drawPath(self.path())
        
        if self.has_type_mismatch():
            output_color = get_type_color(self.output_port.type_name,
                                         self.output_port.registry,
                                         self.output_port.node_type if hasattr(self.output_port, 'node_type') else None)
            input_color = get_type_color(self.input_port.type_name,
                                        self.input_port.registry,
                                        self.input_port.node_type if hasattr(self.input_port, 'node_type') else None)
            gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
            gradient.setColorAt(0, output_color)
            gradient.setColorAt(1, input_color)
            pen = QPen(QBrush(gradient), 2.5)
        elif not self.is_valid():
            if self.output_valid and not self.input_valid:
                gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
                gradient.setColorAt(0, self.normal_pen.color())
                gradient.setColorAt(1, HOUDINI_ERROR)
                pen = QPen(QBrush(gradient), 2.5)
            elif not self.output_valid and self.input_valid:
                gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
                gradient.setColorAt(0, HOUDINI_ERROR)
                gradient.setColorAt(1, self.normal_pen.color())
                pen = QPen(QBrush(gradient), 2.5)
            else:
                pen = self.invalid_pen
        else:
            pen = self.normal_pen
        
        painter.setPen(pen)
        painter.drawPath(self.path())
    
    def expand_connection(self):
        """Expand this connection into subport connections"""
        if self.is_implicit:
            return []
        
        if not self.output_port or not self.input_port:
            return []
        
        if not self.output_port.subport_defs or not self.input_port.subport_defs:
            return []
        
        if not self.output_port.expanded:
            self.output_port.expand()
        if not self.input_port.expanded:
            self.input_port.expand()
        
        output_subports = {sp.name: sp for sp in self.output_port.subport_widgets}
        input_subports = {sp.name: sp for sp in self.input_port.subport_widgets}
        
        new_connections = []
        for name in output_subports:
            if name in input_subports:
                out_sp = output_subports[name]
                in_sp = input_subports[name]
                if out_sp.types_are_compatible(in_sp):
                    conn = Connection(out_sp, in_sp, self.scene())
                    if self.scene():
                        self.scene().addItem(conn)
                    new_connections.append(conn)
        
        self.remove()
        return new_connections
    
    def reconnect(self):
        """Try to reconnect to ports based on stored index paths"""
        if self.output_port and self in self.output_port.connections:
            self.output_port.connections.remove(self)
        if self.input_port and self in self.input_port.connections:
            self.input_port.connections.remove(self)
        
        self.output_port = self._find_port_by_index(self.output_node, self.output_index_path, False)
        self.input_port = self._find_port_by_index(self.input_node, self.input_index_path, True)
        
        self.output_valid = self.output_port is not None
        self.input_valid = self.input_port is not None
        
        if self.output_node and self.output_port:
            self.output_rel_pos = self.output_port.get_scene_pos().y() - self.output_node.pos().y()
            
        if self.input_node and self.input_port:
            self.input_rel_pos = self.input_port.get_scene_pos().y() - self.input_node.pos().y()
        
        if not self.is_implicit and self.output_port:
            color = get_type_color(self.output_port.type_name,
                                  self.output_port.registry,
                                  self.output_port.node_type if hasattr(self.output_port, 'node_type') else None)
            self.normal_pen = QPen(color, 2.5)
        elif not self.is_implicit and self.input_port:
            color = get_type_color(self.input_port.type_name,
                                  self.input_port.registry,
                                  self.input_port.node_type if hasattr(self.input_port, 'node_type') else None)
            self.normal_pen = QPen(color, 2.5)
        
        if self.output_port and self not in self.output_port.connections:
            self.output_port.connections.append(self)
        if self.input_port and self not in self.input_port.connections:
            self.input_port.connections.append(self)
        
        if self.output_port and isinstance(self.output_port, SubportWidget):
            self._expand_hierarchy(self.output_port)
        if self.input_port and isinstance(self.input_port, SubportWidget):
            self._expand_hierarchy(self.input_port)
        
        self.update_path()
        self.update()
    
    def _find_port_by_index(self, node, index_path, is_input):
        """Find port by index path"""
        if not node or not index_path:
            return None
        
        ports = node.input_ports if is_input else node.output_ports
        
        if index_path[0] >= len(ports):
            return None
        
        current_port = ports[index_path[0]]
        
        for idx in index_path[1:]:
            if not current_port.expanded:
                current_port.expand()
            
            if idx >= len(current_port.subport_widgets):
                return None
            
            current_port = current_port.subport_widgets[idx]
        
        return current_port


class NodeWidget(QGraphicsRectItem):
    MIN_WIDTH = 180
    MIN_HEIGHT = 60
    PORT_SPACING = 28
    HEADER_HEIGHT = 32
    
    def __init__(self, node_type, registry, name=None, port_values=None):
        super().__init__()
        self.node_type = node_type
        self.registry = registry
        self.node_name = name or node_type.name
        self.port_values = port_values or []
        self.input_ports = []
        self.output_ports = []
        
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        
        self.setBrush(QBrush(HOUDINI_NODE_BG))
        self.setPen(QPen(HOUDINI_NODE_BORDER, 2))
        
        self.header = QGraphicsTextItem(self.node_name, self)
        self.header.setDefaultTextColor(HOUDINI_TEXT)
        font = QFont("Arial", 10, QFont.Bold)
        self.header.setFont(font)
        self.header.setPos(8, 6)
        
        self._create_ports()
        self.adjust_size_for_expansion()
    
    def _create_ports(self):
        for i, (port_name, port_type) in enumerate(self.node_type.inputs):
            port = PortWidget(port_name, port_type, self.registry, True, None, self, self.node_type)
            port.setParentItem(self)
            self.input_ports.append(port)
            
            label = QGraphicsTextItem(port_name, self)
            label.setDefaultTextColor(HOUDINI_TEXT)
            font = QFont("Arial", 9)
            label.setFont(font)
            port.label = label
        
        for i, (port_name, port_type) in enumerate(self.node_type.outputs):
            port = PortWidget(port_name, port_type, self.registry, False, None, self, self.node_type)
            port.setParentItem(self)
            self.output_ports.append(port)
            
            label = QGraphicsTextItem(port_name, self)
            label.setDefaultTextColor(HOUDINI_TEXT)
            font = QFont("Arial", 9)
            label.setFont(font)
            port.label = label
    
    def change_type(self, new_node_type):
        """Change this node to a different type"""
        view = None
        if self.scene() and self.scene().views():
            view = self.scene().views()[0]
        
        all_connections = []
        if view:
            for conn in view.connections:
                if conn.output_node == self or conn.input_node == self:
                    all_connections.append(conn)
        
        for port in self.input_ports + self.output_ports:
            self._remove_port_connections(port)
        
        for port in self.input_ports + self.output_ports:
            self._clear_port_completely(port)
        self.input_ports.clear()
        self.output_ports.clear()
        
        self.node_type = new_node_type
        self.node_name = new_node_type.name
        self.header.setPlainText(self.node_name)
        
        self.port_values = []
        
        self._create_ports()
        self.adjust_size_for_expansion()
        
        if self.scene() and self.scene().views():
            view = self.scene().views()[0]
            if hasattr(view, '_update_node_ports_matching'):
                view._update_node_ports_matching(self)
        
        for conn in all_connections:
            if not conn.is_implicit:
                conn.reconnect()
    
    def _remove_port_connections(self, port):
        """Remove connections from port's list"""
        for subport in port.subport_widgets[:]:
            self._remove_port_connections(subport)
        port.connections.clear()
    
    def _clear_port_completely(self, port):
        """Completely remove a port"""
        for subport in port.subport_widgets[:]:
            self._clear_port_completely(subport)
        
        if hasattr(port, 'expansion_widget') and port.expansion_widget:
            if port.expansion_widget.scene():
                port.expansion_widget.scene().removeItem(port.expansion_widget)
            port.expansion_widget = None
        
        if hasattr(port, 'label') and port.label:
            if port.label.scene():
                port.label.scene().removeItem(port.label)
            port.label = None
        
        if port.scene():
            port.scene().removeItem(port)
    
    def adjust_size_for_expansion(self, expanding_port=None, original_port_pos=None):
        def count_all_visible_items(ports):
            count = 0
            for port in ports:
                count += 1
                if port.expanded and port.subport_widgets:
                    count += count_nested_subports(port.subport_widgets)
            return count
        
        def count_nested_subports(subports):
            count = 0
            for subport in subports:
                count += 1
                if subport.expanded and subport.subport_widgets:
                    count += count_nested_subports(subport.subport_widgets)
            return count
        
        visible_inputs = count_all_visible_items(self.input_ports)
        visible_outputs = count_all_visible_items(self.output_ports)
        
        max_items = max(visible_inputs, visible_outputs)
        required_height = max_items * self.PORT_SPACING + self.HEADER_HEIGHT + 15
        height = max(self.MIN_HEIGHT, required_height)
        width = self.MIN_WIDTH
        
        if expanding_port and original_port_pos:
            self.setRect(0, 0, width, height)
            self._position_ports()
            
            new_port_scene_pos = expanding_port.get_scene_pos()
            delta_y = original_port_pos.y() - new_port_scene_pos.y()
            
            if abs(delta_y) > 0.1:
                self.setPos(self.pos().x(), self.pos().y() + delta_y)
        else:
            self.setRect(0, 0, width, height)
            self._position_ports()
        
        self._update_all_expansion_positions()
        self._update_all_connections()
    
    def _position_ports(self):
        width = self.rect().width()
        
        def calculate_spacing_for_port(port):
            space = self.PORT_SPACING
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    space += calculate_spacing_for_subport(subport)
            return space
        
        def calculate_spacing_for_subport(subport):
            space = PortWidget.SUBPORT_SPACING
            if subport.expanded and subport.subport_widgets:
                for nested in subport.subport_widgets:
                    space += calculate_spacing_for_subport(nested)
            return space
        
        current_y = self.HEADER_HEIGHT
        for i, port in enumerate(self.input_ports):
            current_y += self.PORT_SPACING
            port.setPos(0, current_y)
            if hasattr(port, 'label'):
                port.label.setPos(PortWidget.PORT_RADIUS * 2 + 5, current_y - 8)
            
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    subport_spacing = calculate_spacing_for_subport(subport)
                    current_y += subport_spacing
        
        current_y = self.HEADER_HEIGHT
        for i, port in enumerate(self.output_ports):
            current_y += self.PORT_SPACING
            port.setPos(width, current_y)
            if hasattr(port, 'label'):
                label_width = port.label.boundingRect().width()
                port.label.setPos(width - PortWidget.PORT_RADIUS * 2 - label_width - 5, current_y - 8)
            
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    subport_spacing = calculate_spacing_for_subport(subport)
                    current_y += subport_spacing
    
    def _update_all_expansion_positions(self):
        for port in self.input_ports + self.output_ports:
            self._update_port_expansion_positions(port)
    
    def _update_port_expansion_positions(self, port):
        if port.expanded and port.expansion_widget:
            port.expansion_widget._update_subport_positions()
        for subport in port.subport_widgets:
            self._update_port_expansion_positions(subport)
    
    def _update_all_connections(self):
        for port in self.input_ports + self.output_ports:
            self._update_port_connections(port)
    
    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionHasChanged:
            for port in self.input_ports + self.output_ports:
                self._update_port_connections(port)
            
            if self.scene() and self.scene().views():
                view = self.scene().views()[0]
                if hasattr(view, 'connections'):
                    for conn in view.connections:
                        if (conn.output_node == self and not conn.output_valid) or \
                           (conn.input_node == self and not conn.input_valid):
                            conn.update_path()
        
        return super().itemChange(change, value)
    
    def _update_port_connections(self, port):
        try:
            for conn in port.connections[:]:
                conn.update_path()
            for subport in port.subport_widgets[:]:
                self._update_subport_connections(subport)
        except RuntimeError:
            pass
    
    def _update_subport_connections(self, subport):
        try:
            for conn in subport.connections[:]:
                conn.update_path()
            for nested_subport in subport.subport_widgets[:]:
                self._update_subport_connections(nested_subport)
        except RuntimeError:
            pass
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        
        if self.isSelected():
            glow_pen = QPen(QColor(255, 255, 255, 180), 6.0)
            painter.setPen(glow_pen)
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(self.rect())
        
        self.setPen(QPen(HOUDINI_NODE_BORDER, 1.5))
        painter.setPen(self.pen())
        painter.setBrush(self.brush())
        painter.drawRect(self.rect())
    
    def get_all_ports(self):
        all_ports = []
        
        def collect_subports(subport):
            all_ports.append(subport)
            for nested_subport in subport.subport_widgets:
                collect_subports(nested_subport)
        
        for port in self.input_ports + self.output_ports:
            all_ports.append(port)
            for subport in port.subport_widgets:
                collect_subports(subport)
        
        return all_ports
    
    def to_dict(self):
        """Export node in Lean JSON format"""
        def port_to_lean_json(port_name, port_type_name):
            if port_type_name in self.node_type.custom_port_types:
                custom_type = self.node_type.custom_port_types[port_type_name]
                subports_json = []
                for sp_name, sp_type in custom_type.subports:
                    subports_json.append(port_to_lean_json(sp_name, sp_type))
                return {
                    'struct': {
                        'name': port_name,
                        'type': port_type_name,
                        'subports': subports_json
                    }
                }
            else:
                return {
                    'builtin': {
                        'name': port_name,
                        'type': port_type_name
                    }
                }
        
        type_dict = {
            'name': self.node_type.name,
            'leanConstant': self.node_type.lean_constant,
            'exposeImplicitArgs': self.node_type.expose_implicit_args,
            'inputs': [port_to_lean_json(name, type_) for name, type_ in self.node_type.inputs],
            'outputs': [port_to_lean_json(name, type_) for name, type_ in self.node_type.outputs]
        }
        
        return {
            'name': self.node_name,
            'type': type_dict,
            'portValues': self.port_values,
            'x': self.pos().x(),
            'y': self.pos().y()
        }


class NodeEditorScene(QGraphicsScene):
    def __init__(self):
        super().__init__()
        self.temp_connection = None
        self.drag_start_port = None
        self.setBackgroundBrush(QBrush(HOUDINI_BG_DARK))
        self.setSceneRect(-10000, -10000, 20000, 20000)


class NodeEditorView(QGraphicsView):
    def __init__(self, registry):
        super().__init__()
        self.registry = registry
        self.editor_scene = NodeEditorScene()
        self.setScene(self.editor_scene)
        
        self.setRenderHint(QPainter.Antialiasing)
        self.setRenderHint(QPainter.SmoothPixmapTransform)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        self.nodes = []
        self.connections = []
        self.last_mouse_pos = QPointF(0, 0)
        self.is_dragging_connection = False
        self.is_panning = False
        self.pan_start_pos = QPointF()
        self.drag_locked_ports = []
        
        self.allow_structural_matching = True
        self.show_implicit_connections = False
        
        self.editor_scene.selectionChanged.connect(self.on_selection_changed)
    
    def set_structural_matching(self, enabled):
        self.allow_structural_matching = enabled
        for node in self.nodes:
            self._update_node_ports_matching(node)
    
    def set_show_implicit(self, enabled):
        self.show_implicit_connections = enabled
        for conn in self.connections:
            if conn.is_implicit:
                conn.setVisible(enabled)
    
    def _update_node_ports_matching(self, node):
        def update_port(port):
            port.allow_structural_matching = self.allow_structural_matching
            for subport in port.subport_widgets:
                update_port(subport)
        
        for port in node.input_ports + node.output_ports:
            update_port(port)
    
    def on_selection_changed(self):
        selected = self.editor_scene.selectedItems()
        selected_nodes = [item for item in selected if isinstance(item, NodeWidget)]
        if hasattr(self, 'selection_changed_callback'):
            self.selection_changed_callback(selected_nodes)
    
    def drawBackground(self, painter, rect):
        super().drawBackground(painter, rect)
        
        grid_size = 20
        left = int(rect.left()) - (int(rect.left()) % grid_size)
        top = int(rect.top()) - (int(rect.top()) % grid_size)
        
        fine_lines = []
        thick_lines = []
        
        x = left
        while x < rect.right():
            if x % 100 == 0:
                thick_lines.append((x, rect.top(), x, rect.bottom()))
            else:
                fine_lines.append((x, rect.top(), x, rect.bottom()))
            x += grid_size
        
        y = top
        while y < rect.bottom():
            if y % 100 == 0:
                thick_lines.append((rect.left(), y, rect.right(), y))
            else:
                fine_lines.append((rect.left(), y, rect.right(), y))
            y += grid_size
        
        painter.setPen(QPen(HOUDINI_GRID_FINE, 1))
        for line in fine_lines:
            painter.drawLine(line[0], line[1], line[2], line[3])
        
        painter.setPen(QPen(HOUDINI_GRID_THICK, 1))
        for line in thick_lines:
            painter.drawLine(line[0], line[1], line[2], line[3])
    
    def _lock_port_hierarchy(self, port):
        self.drag_locked_ports.append(port)
        
        if isinstance(port, SubportWidget):
            current = port.parent_port
            while current:
                self.drag_locked_ports.append(current)
                if hasattr(current, 'parent_port'):
                    current = current.parent_port
                else:
                    break
    
    def _unlock_all_ports(self):
        self.drag_locked_ports.clear()
    
    def _is_port_locked(self, port):
        return port in self.drag_locked_ports
    
    def contextMenuEvent(self, event):
        item = self.itemAt(event.pos())
        if item is None or isinstance(item, QGraphicsTextItem):
            self.show_node_creation_menu(event.pos())
        else:
            super().contextMenuEvent(event)
    
    def mousePressEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        self.last_mouse_pos = self.mapToScene(pos.toPoint())
        
        items = self.items(pos.toPoint())
        
        if event.button() == Qt.LeftButton:
            port_item = None
            for item in items:
                if isinstance(item, (PortWidget, SubportWidget)):
                    port_item = item
                    break
            
            if port_item:
                self.setDragMode(QGraphicsView.NoDrag)
                self._lock_port_hierarchy(port_item)
                self.start_connection(port_item)
                self.is_dragging_connection = True
                event.accept()
                return
            else:
                self.setDragMode(QGraphicsView.RubberBandDrag)
        
        elif event.button() == Qt.MiddleButton:
            self.setDragMode(QGraphicsView.NoDrag)
            self.is_panning = True
            self.pan_start_pos = pos
            self.setCursor(Qt.ClosedHandCursor)
            event.accept()
            return
        
        super().mousePressEvent(event)
    
    def mouseMoveEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        self.last_mouse_pos = self.mapToScene(pos.toPoint())
        
        if self.is_panning:
            delta = pos - self.pan_start_pos
            self.pan_start_pos = pos
            
            self.horizontalScrollBar().setValue(
                self.horizontalScrollBar().value() - int(delta.x())
            )
            self.verticalScrollBar().setValue(
                self.verticalScrollBar().value() - int(delta.y())
            )
            event.accept()
            return
        
        if self.is_dragging_connection and self.editor_scene.temp_connection:
            try:
                if not self.editor_scene.drag_start_port:
                    self.is_dragging_connection = False
                    self.setDragMode(QGraphicsView.RubberBandDrag)
                    return
                    
                start_pos = self.editor_scene.drag_start_port.get_scene_pos()
                end_pos = self.last_mouse_pos
                
                path = QPainterPath()
                path.moveTo(start_pos)
                
                is_input_drag = self.editor_scene.drag_start_port.is_input
                ctrl_offset = abs(end_pos.x() - start_pos.x()) * 0.5
                
                if is_input_drag:
                    ctrl1 = QPointF(start_pos.x() - ctrl_offset, start_pos.y())
                    ctrl2 = QPointF(end_pos.x() + ctrl_offset, end_pos.y())
                else:
                    ctrl1 = QPointF(start_pos.x() + ctrl_offset, start_pos.y())
                    ctrl2 = QPointF(end_pos.x() - ctrl_offset, end_pos.y())
                
                path.cubicTo(ctrl1, ctrl2, end_pos)
                
                self.editor_scene.temp_connection.setPath(path)
                
                items = self.items(pos.toPoint())
                for item in items:
                    if isinstance(item, (PortWidget, SubportWidget)):
                        if item.is_input and item.is_occupied():
                            break
                        if item.subport_defs and not item.expanded:
                            item.expand()
                        break
                
                event.accept()
                return
            except RuntimeError:
                self.is_dragging_connection = False
                if self.editor_scene.temp_connection:
                    self.editor_scene.removeItem(self.editor_scene.temp_connection)
                    self.editor_scene.temp_connection = None
                self.editor_scene.drag_start_port = None
                self._unlock_all_ports()
                self.setDragMode(QGraphicsView.RubberBandDrag)
                return
        
        super().mouseMoveEvent(event)
    
    def mouseReleaseEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        
        if event.button() == Qt.MiddleButton:
            self.is_panning = False
            self.setDragMode(QGraphicsView.RubberBandDrag)
            self.setCursor(Qt.ArrowCursor)
            event.accept()
            return
        
        if event.button() == Qt.LeftButton and self.is_dragging_connection:
            self.is_dragging_connection = False
            
            if self.editor_scene.temp_connection:
                items = self.items(pos.toPoint())
                
                target_port = None
                for item in items:
                    if isinstance(item, (PortWidget, SubportWidget)):
                        target_port = item
                        break
                
                if target_port and self.editor_scene.drag_start_port:
                    start_port = self.editor_scene.drag_start_port
                    
                    try:
                        _ = start_port.scene()
                        _ = target_port.scene()
                        
                        if start_port.is_connectable_to(target_port):
                            output_port = start_port if not start_port.is_input else target_port
                            input_port = target_port if target_port.is_input else start_port
                            
                            conn = Connection(output_port, input_port, self.editor_scene)
                            self.editor_scene.addItem(conn)
                            self.connections.append(conn)
                    except RuntimeError:
                        pass
                
                self.editor_scene.removeItem(self.editor_scene.temp_connection)
                self.editor_scene.temp_connection = None
                self.editor_scene.drag_start_port = None
            
            self._unlock_all_ports()
            self.setDragMode(QGraphicsView.RubberBandDrag)
            event.accept()
            return
        
        super().mouseReleaseEvent(event)
    
    def start_connection(self, port):
        self.editor_scene.drag_start_port = port
        self.editor_scene.temp_connection = QGraphicsPathItem()
        color = get_type_color(port.type_name, 
                              port.registry,
                              port.node_type if hasattr(port, 'node_type') else None)
        self.editor_scene.temp_connection.setPen(QPen(color, 2.5, Qt.DashLine))
        self.editor_scene.addItem(self.editor_scene.temp_connection)
    
    def show_node_creation_menu(self, view_pos):
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 25px 6px 15px;
                border-radius: 3px;
            }}
            QMenu::item:selected {{
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QMenu::separator {{
                height: 1px;
                background: {HOUDINI_NODE_BORDER.name()};
                margin: 4px 0px;
            }}
        """)
        
        scene_pos = self.mapToScene(view_pos)
        
        categories = {}
        for node_type_name in sorted(self.registry.node_types.keys()):
            if '_' in node_type_name:
                category = node_type_name.split('_')[0]
            else:
                category = "Other"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(node_type_name)
        
        for category in sorted(categories.keys()):
            if len(categories) > 1:
                submenu = menu.addMenu(category)
                submenu.setStyleSheet(menu.styleSheet())
            else:
                submenu = menu
            
            for node_type_name in sorted(categories[category]):
                action = submenu.addAction(node_type_name)
                action.triggered.connect(lambda checked=False, name=node_type_name, pos=scene_pos: 
                                       self.add_node(name, pos))
        
        menu.exec(self.mapToGlobal(view_pos))
    
    def show_node_type_menu(self, node, view_pos):
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 25px 6px 15px;
                border-radius: 3px;
            }}
            QMenu::item:selected {{
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QMenu::separator {{
                height: 1px;
                background: {HOUDINI_NODE_BORDER.name()};
                margin: 4px 0px;
            }}
        """)
        
        categories = {}
        for node_type_name in sorted(self.registry.node_types.keys()):
            if '_' in node_type_name:
                category = node_type_name.split('_')[0]
            else:
                category = "Other"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(node_type_name)
        
        for category in sorted(categories.keys()):
            if len(categories) > 1:
                submenu = menu.addMenu(category)
                submenu.setStyleSheet(menu.styleSheet())
            else:
                submenu = menu
            
            for node_type_name in sorted(categories[category]):
                node_type = self.registry.get_node_type(node_type_name)
                action = submenu.addAction(node_type_name)
                action.triggered.connect(lambda checked=False, n=node, nt=node_type: 
                                       n.change_type(nt))
        
        menu.exec(self.mapToGlobal(view_pos))
    
    def add_node(self, node_type_name, pos):
        node_type = self.registry.get_node_type(node_type_name)
            
        if node_type:
            base_name = node_type.name
            counter = 1
            name = base_name
            existing_names = {node.node_name for node in self.nodes}
            while name in existing_names:
                name = f"{base_name}_{counter}"
                counter += 1
            
            node = NodeWidget(node_type, self.registry, name)
            node.setPos(pos)
            self.editor_scene.addItem(node)
            self.nodes.append(node)
            
            self._update_node_ports_matching(node)
            
            return node
    
    def delete_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                all_ports = item.get_all_ports()
                for port in all_ports:
                    for conn in port.connections[:]:
                        conn.remove()
                        if conn in self.connections:
                            self.connections.remove(conn)
                
                self.nodes.remove(item)
                self.editor_scene.removeItem(item)
            
            elif isinstance(item, Connection):
                if not item.is_implicit:
                    item.remove()
                    if item in self.connections:
                        self.connections.remove(item)
    
    def rename_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                text, ok = QInputDialog.getText(self, "Rename Node", 
                                               "New name:", QLineEdit.Normal,
                                               item.node_name)
                if ok and text:
                    item.node_name = text
                    item.header.setPlainText(text)
                break
    
    def change_type_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                view_pos = self.mapFromScene(item.pos())
                self.show_node_type_menu(item, view_pos)
                break
    
    def update_selected_node_type(self, type_json):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                try:
                    node_type = self.registry._parse_node_type(type_json)
                    if node_type:
                        item.change_type(node_type)
                except Exception as e:
                    print(f"Error updating node type: {e}")
                break
    
    def frame_all(self):
        if not self.nodes:
            return
        
        min_x = min(node.pos().x() for node in self.nodes)
        max_x = max(node.pos().x() + node.rect().width() for node in self.nodes)
        min_y = min(node.pos().y() for node in self.nodes)
        max_y = max(node.pos().y() + node.rect().height() for node in self.nodes)
        
        padding = 100
        min_x -= padding
        max_x += padding
        min_y -= padding
        max_y += padding
        
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        width = max_x - min_x
        height = max_y - min_y
        
        rect = QRectF(min_x, min_y, width, height)
        self.fitInView(rect, Qt.KeepAspectRatio)
        
        if self.transform().m11() > 2.0:
            self.resetTransform()
            self.scale(1.0, 1.0)
            self.centerOn(center_x, center_y)
    
    def save_to_json(self):
        nodes_data = []
        connections_data = []
        
        for node in self.nodes:
            nodes_data.append(node.to_dict())
        
        for conn in self.connections:
            connections_data.append({
                'outputNodeName': conn.output_node.node_name if conn.output_node else None,
                'outputIndex': conn.output_index_path,
                'inputNodeName': conn.input_node.node_name if conn.input_node else None,
                'inputIndex': conn.input_index_path,
                'outputRelPos': conn.output_rel_pos,
                'inputRelPos': conn.input_rel_pos,
                'isImplicit': conn.is_implicit
            })
        
        port_types_data = []
        for type_name, port_type in self.registry.port_types.items():
            if port_type.subports:
                subports_json = []
                for sp_name, sp_type in port_type.subports:
                    subports_json.append({
                        'builtin': {'name': sp_name, 'type': sp_type}
                    })
                port_types_data.append({
                    'struct': {
                        'name': port_type.name,
                        'type': type_name,
                        'subports': subports_json
                    }
                })
            else:
                port_types_data.append({
                    'builtin': {
                        'name': port_type.name,
                        'type': type_name
                    }
                })
        
        node_types_data = []
        for node_type in self.registry.node_types.values():
            def port_to_lean_json(port_name, port_type_name):
                if port_type_name in node_type.custom_port_types:
                    custom_type = node_type.custom_port_types[port_type_name]
                    subports_json = []
                    for sp_name, sp_type in custom_type.subports:
                        subports_json.append(port_to_lean_json(sp_name, sp_type))
                    return {
                        'struct': {
                            'name': port_name,
                            'type': port_type_name,
                            'subports': subports_json
                        }
                    }
                else:
                    return {
                        'builtin': {
                            'name': port_name,
                            'type': port_type_name
                        }
                    }
            
            node_types_data.append({
                'name': node_type.name,
                'leanConstant': node_type.lean_constant,
                'exposeImplicitArgs': node_type.expose_implicit_args,
                'inputs': [port_to_lean_json(name, type_) for name, type_ in node_type.inputs],
                'outputs': [port_to_lean_json(name, type_) for name, type_ in node_type.outputs]
            })
        
        return {
            'portTypes': port_types_data,
            'nodeTypes': node_types_data,
            'nodes': nodes_data,
            'connections': connections_data
        }
    
    def load_from_json(self, data):
        if 'portTypes' in data or 'nodeTypes' in data:
            self.registry.load_from_json(data)
        
        for node in self.nodes[:]:
            all_ports = node.get_all_ports()
            for port in all_ports:
                for conn in port.connections[:]:
                    if conn in self.connections:
                        self.connections.remove(conn)
                    if conn.scene():
                        self.editor_scene.removeItem(conn)
            self.editor_scene.removeItem(node)
        self.nodes.clear()
        self.connections.clear()
        
        node_map = {}
        for node_data in data.get('nodes', []):
            type_data = node_data.get('type', {})
            node_type = self.registry._parse_node_type(type_data)
            
            if node_type:
                port_values = node_data.get('portValues', [])
                node = NodeWidget(node_type, self.registry, node_data['name'], port_values)
                node.setPos(QPointF(node_data['x'], node_data['y']))
                self.editor_scene.addItem(node)
                self.nodes.append(node)
                self._update_node_ports_matching(node)
                node_map[node_data['name']] = node
        
        for conn_data in data.get('connections', []):
            output_node = node_map.get(conn_data['outputNodeName'])
            input_node = node_map.get(conn_data['inputNodeName'])
            output_index_path = conn_data.get('outputIndex', [])
            input_index_path = conn_data.get('inputIndex', [])
            is_implicit = conn_data.get('isImplicit', False)
            
            if output_node or input_node:
                output_port = None
                input_port = None
                
                if output_node and output_index_path:
                    output_port = self._find_port_by_index(output_node, output_index_path, False)
                
                if input_node and input_index_path:
                    input_port = self._find_port_by_index(input_node, input_index_path, True)
                
                conn = Connection(output_port, input_port, self.editor_scene, 
                                output_index_path, input_index_path, is_implicit)
                conn.output_node = output_node
                conn.input_node = input_node
                conn.output_rel_pos = conn_data.get('outputRelPos', 0)
                conn.input_rel_pos = conn_data.get('inputRelPos', 0)
                conn.output_valid = output_port is not None
                conn.input_valid = input_port is not None
                
                conn.setVisible(not is_implicit or self.show_implicit_connections)
                
                self.editor_scene.addItem(conn)
                self.connections.append(conn)
    
    def _find_port_by_index(self, node, index_path, is_input):
        if not node or not index_path:
            return None
        
        ports = node.input_ports if is_input else node.output_ports
        
        if index_path[0] >= len(ports):
            return None
        
        current_port = ports[index_path[0]]
        
        for idx in index_path[1:]:
            if not current_port.expanded:
                current_port.expand()
            
            if idx >= len(current_port.subport_widgets):
                return None
            
            current_port = current_port.subport_widgets[idx]
        
        return current_port
    
    def expand_selected_connections(self):
        selected = self.editor_scene.selectedItems()
        
        new_connections = []
        for item in selected:
            if isinstance(item, Connection) and not item.is_implicit:
                expanded = item.expand_connection()
                new_connections.extend(expanded)
                for conn in expanded:
                    if conn not in self.connections:
                        self.connections.append(conn)
                if item in self.connections:
                    self.connections.remove(item)
        
        for conn in new_connections:
            conn.setSelected(True)

    def collapse_selected_connections(self):
        selected = self.editor_scene.selectedItems()
        selected_connections = [item for item in selected if isinstance(item, Connection) and not item.is_implicit]
        
        if not selected_connections:
            return
        
        groups = {}
        
        for conn in selected_connections:
            if not conn.output_port or not conn.input_port:
                continue
            
            output_parent = self._get_parent_port(conn.output_port)
            input_parent = self._get_parent_port(conn.input_port)
            
            if not output_parent or not input_parent:
                continue
            
            key = (id(output_parent), id(input_parent), output_parent, input_parent)
            if key not in groups:
                groups[key] = []
            groups[key].append(conn)
        
        wires_to_flash = []
        new_parent_connections = []
        
        for (_, _, output_parent, input_parent), conns in groups.items():
            result = self._try_collapse_group(output_parent, input_parent, conns)
            if result == 'blocked':
                wires_to_flash.extend(conns)
            elif isinstance(result, Connection):
                new_parent_connections.append(result)
        
        for conn in new_parent_connections:
            conn.setSelected(True)
        
        if wires_to_flash:
            self._flash_wires_red(wires_to_flash)
    
    def _get_parent_port(self, port):
        if isinstance(port, SubportWidget):
            return port.parent_port
        return None
    
    def _try_collapse_group(self, output_parent, input_parent, selected_conns):
        if output_parent.connections or input_parent.connections:
            return 'blocked'
        
        all_output_subports = output_parent.subport_widgets if output_parent.expanded else []
        all_input_subports = input_parent.subport_widgets if input_parent.expanded else []
        
        if not all_output_subports or not all_input_subports:
            return 'skip'
        
        selected_output_subports = set()
        selected_input_subports = set()
        
        for conn in selected_conns:
            selected_output_subports.add(conn.output_port)
            selected_input_subports.add(conn.input_port)
        
        for out_subport in all_output_subports:
            if out_subport.connections and out_subport not in selected_output_subports:
                return 'blocked'
        
        for in_subport in all_input_subports:
            if in_subport.connections and in_subport not in selected_input_subports:
                return 'blocked'
        
        for conn in selected_conns:
            conn.remove()
            if conn in self.connections:
                self.connections.remove(conn)
        
        parent_conn = Connection(output_parent, input_parent, self.editor_scene)
        self.editor_scene.addItem(parent_conn)
        self.connections.append(parent_conn)
        
        output_parent.collapse()
        input_parent.collapse()
        
        return parent_conn
    
    def _flash_wires_red(self, wires):
        original_pens = {}
        
        for wire in wires:
            original_pens[wire] = wire.pen()
            wire.setPen(QPen(HOUDINI_ERROR, 3.5))
            wire.update()
        
        def restore_pens():
            for wire in wires:
                if wire in original_pens and wire.scene():
                    wire.setPen(original_pens[wire])
                    wire.update()
        
        QTimer.singleShot(300, restore_pens)
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete or event.key() == Qt.Key_Backspace:
            self.delete_selected()
        elif event.key() == Qt.Key_F2:
            self.rename_selected()
        elif event.key() == Qt.Key_M:
            self.change_type_selected()
        elif event.key() == Qt.Key_Tab:
            view_pos = self.mapFromScene(self.last_mouse_pos)
            self.show_node_creation_menu(view_pos)
        elif event.key() == Qt.Key_G:
            self.frame_all()
        elif event.key() == Qt.Key_E:
            self.expand_selected_connections()
        elif event.key() == Qt.Key_C:
            self.collapse_selected_connections()
        else:
            super().keyPressEvent(event)
    
    def wheelEvent(self, event):
        zoom_factor = 1.12
        if event.angleDelta().y() > 0:
            self.scale(zoom_factor, zoom_factor)
        else:
            self.scale(1 / zoom_factor, 1 / zoom_factor)


class NodeEditorWidget(QWidget):
    def __init__(self):
        super().__init__()
        self.registry = NodeTypeRegistry()
        self._load_default_types()
        self._create_ui()
        self.current_selected_node = None
    
    def _load_default_types(self):
        default_config = {
            "portTypes": [
                {"builtin": {"name": "type", "type": "Type"}},
                {"builtin": {"name": "value", "type": "Float"}},
                {"builtin": {"name": "value", "type": "Int"}},
                {"builtin": {"name": "value", "type": "String"}},
                {"builtin": {"name": "wildcard", "type": "?_"}},
                {"struct": {
                    "name": "v",
                    "type": "Vector3",
                    "subports": [
                        {"builtin": {"name": "x", "type": "Float"}},
                        {"builtin": {"name": "y", "type": "Float"}},
                        {"builtin": {"name": "z", "type": "Float"}}
                    ]
                }},
                {"struct": {
                    "name": "particle",
                    "type": "Particle",
                    "subports": [
                        {"builtin": {"name": "position", "type": "Vector3"}},
                        {"builtin": {"name": "velocity", "type": "Vector3"}}
                    ]
                }}
            ],
            "nodeTypes": [
                {
                    "name": "Float_Add",
                    "leanConstant": "Float.add",
                    "exposeImplicitArgs": False,
                    "inputs": [
                        {"builtin": {"name": "a", "type": "Float"}},
                        {"builtin": {"name": "b", "type": "Float"}}
                    ],
                    "outputs": [
                        {"builtin": {"name": "add", "type": "Float"}}
                    ]
                },
                {
                    "name": "add",
                    "leanConstant": "HAdd.hAdd",
                    "exposeImplicitArgs": False,
                    "inputs": [
                        {"builtin": {"name": "a", "type": "?_"}},
                        {"builtin": {"name": "b", "type": "?_"}}
                    ],
                    "outputs": [
                        {"builtin": {"name": "add", "type": "?_"}}
                    ]
                },
                {
                    "name": "makeVector3",
                    "leanConstant": "Vector3.mk",
                    "exposeImplicitArgs": False,
                    "inputs": [
                        {"builtin": {"name": "x", "type": "Float"}},
                        {"builtin": {"name": "y", "type": "Float"}},
                        {"builtin": {"name": "z", "type": "Float"}}
                    ],
                    "outputs": [
                        {"builtin": {"name": "vector", "type": "Vector3"}}
                    ]
                }
            ]
        }
        self.registry.load_from_json(default_config)
    
    def _create_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        toolbar_frame = QFrame()
        toolbar_frame.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG.name()};
                border-bottom: 1px solid {HOUDINI_NODE_BORDER.name()};
            }}
            QPushButton {{
                background-color: {HOUDINI_BG_LIGHT.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 4px 12px;
                font-size: 11px;
            }}
            QPushButton:hover {{
                background-color: {HOUDINI_BG_LIGHT.lighter(110).name()};
            }}
            QPushButton:pressed {{
                background-color: {HOUDINI_BG.name()};
            }}
            QLabel {{
                color: {HOUDINI_TEXT_DIM.name()};
                font-size: 10px;
                padding: 0 8px;
            }}
            QCheckBox {{
                color: {HOUDINI_TEXT.name()};
                font-size: 10px;
                padding: 0 8px;
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QCheckBox::indicator:checked {{
                background-color: {get_type_color('Float').name()};
            }}
        """)
        
        toolbar_layout = QHBoxLayout(toolbar_frame)
        toolbar_layout.setContentsMargins(4, 4, 4, 4)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_graph)
        toolbar_layout.addWidget(save_btn)
        
        load_btn = QPushButton("Load")
        load_btn.clicked.connect(self.load_graph)
        toolbar_layout.addWidget(load_btn)
        
        toolbar_layout.addSpacing(8)
        
        save_to_node_btn = QPushButton("Save to Node")
        save_to_node_btn.clicked.connect(self.save_to_node)
        toolbar_layout.addWidget(save_to_node_btn)
        
        load_from_node_btn = QPushButton("Load from Node")
        load_from_node_btn.clicked.connect(self.load_from_node)
        toolbar_layout.addWidget(load_from_node_btn)
        
        toolbar_layout.addSpacing(8)
        
        load_types_btn = QPushButton("Load Types")
        load_types_btn.clicked.connect(self.load_node_types)
        toolbar_layout.addWidget(load_types_btn)
        
        toolbar_layout.addSpacing(8)
        
        self.structural_matching_cb = QCheckBox("Structural Type Matching")
        self.structural_matching_cb.setChecked(True)
        self.structural_matching_cb.toggled.connect(self.on_structural_matching_changed)
        toolbar_layout.addWidget(self.structural_matching_cb)
        
        toolbar_layout.addSpacing(8)
        
        self.show_implicit_cb = QCheckBox("Show Implicit Connections")
        self.show_implicit_cb.setChecked(False)
        self.show_implicit_cb.toggled.connect(self.on_show_implicit_changed)
        toolbar_layout.addWidget(self.show_implicit_cb)
        
        toolbar_layout.addStretch()
        
        instructions = QLabel("Drag: select | RMB/Tab: add | M: change type | E: expand | C: collapse | Del: remove | F2: rename | G: frame")
        toolbar_layout.addWidget(instructions)
        
        layout.addWidget(toolbar_frame)
        
        splitter = QSplitter(Qt.Horizontal)
        splitter.setStyleSheet(f"""
            QSplitter::handle {{
                background-color: {HOUDINI_NODE_BORDER.name()};
                width: 2px;
            }}
        """)
        
        editor_panel = self._create_editor_panel()
        splitter.addWidget(editor_panel)
        
        self.editor = NodeEditorView(self.registry)
        self.editor.selection_changed_callback = self.on_node_selection_changed
        splitter.addWidget(self.editor)
        
        splitter.setSizes([200, 800])
        
        layout.addWidget(splitter)
        
        self.editor.centerOn(0, 0)
    
    def _create_editor_panel(self):
        panel = QFrame()
        panel.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG_DARK.name()};
                border-right: 1px solid {HOUDINI_NODE_BORDER.name()};
            }}
            QLineEdit {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 4px 8px;
                font-size: 11px;
            }}
            QLineEdit:disabled {{
                background-color: {HOUDINI_BG_DARK.name()};
                color: {HOUDINI_TEXT_DIM.name()};
            }}
            QLabel {{
                color: {HOUDINI_TEXT.name()};
                font-size: 11px;
                padding: 4px 4px 4px 4px;
            }}
            QPushButton {{
                background-color: {HOUDINI_BG_LIGHT.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 6px 12px;
                font-size: 11px;
            }}
            QPushButton:hover {{
                background-color: {HOUDINI_BG_LIGHT.lighter(110).name()};
            }}
            QPushButton:pressed {{
                background-color: {HOUDINI_BG.name()};
            }}
            QPushButton:disabled {{
                background-color: {HOUDINI_BG_DARK.name()};
                color: {HOUDINI_TEXT_DIM.name()};
            }}
        """)
        
        panel_layout = QVBoxLayout(panel)
        panel_layout.setContentsMargins(0, 0, 0, 0)
        panel_layout.setSpacing(0)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet(f"""
            QScrollArea {{
                border: none;
                background-color: {HOUDINI_BG_DARK.name()};
            }}
        """)
        
        content = QWidget()
        content_layout = QVBoxLayout(content)
        content_layout.setContentsMargins(8, 8, 8, 8)
        content_layout.setSpacing(8)
        
        title = QLabel("Node Editor")
        title.setStyleSheet(f"font-weight: bold; font-size: 12px; padding: 4px;")
        content_layout.addWidget(title)
        
        name_label = QLabel("Node Name:")
        content_layout.addWidget(name_label)
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Node name...")
        content_layout.addWidget(self.name_edit)
        
        lean_label = QLabel("Lean Constant:")
        content_layout.addWidget(lean_label)
        self.lean_edit = QLineEdit()
        self.lean_edit.setPlaceholderText("Lean.constant.name")
        content_layout.addWidget(self.lean_edit)
        
        type_label = QLabel("Type Name:")
        content_layout.addWidget(type_label)
        self.type_name_edit = QLineEdit()
        self.type_name_edit.setPlaceholderText("TypeName")
        content_layout.addWidget(self.type_name_edit)
        
        inputs_header = QLabel("Input Ports:")
        inputs_header.setStyleSheet(f"font-weight: bold; font-size: 11px; padding-top: 8px;")
        content_layout.addWidget(inputs_header)
        
        self.inputs_layout = QVBoxLayout()
        self.inputs_layout.setSpacing(4)
        content_layout.addLayout(self.inputs_layout)
        
        inputs_btn_layout = QHBoxLayout()
        self.add_input_btn = QPushButton("+")
        self.add_input_btn.setMaximumWidth(30)
        self.add_input_btn.clicked.connect(self.add_input_port)
        self.remove_input_btn = QPushButton("-")
        self.remove_input_btn.setMaximumWidth(30)
        self.remove_input_btn.clicked.connect(self.remove_input_port)
        inputs_btn_layout.addWidget(self.add_input_btn)
        inputs_btn_layout.addWidget(self.remove_input_btn)
        inputs_btn_layout.addStretch()
        content_layout.addLayout(inputs_btn_layout)
        
        outputs_header = QLabel("Output Ports:")
        outputs_header.setStyleSheet(f"font-weight: bold; font-size: 11px; padding-top: 8px;")
        content_layout.addWidget(outputs_header)
        
        self.outputs_layout = QVBoxLayout()
        self.outputs_layout.setSpacing(4)
        content_layout.addLayout(self.outputs_layout)
        
        outputs_btn_layout = QHBoxLayout()
        self.add_output_btn = QPushButton("+")
        self.add_output_btn.setMaximumWidth(30)
        self.add_output_btn.clicked.connect(self.add_output_port)
        self.remove_output_btn = QPushButton("-")
        self.remove_output_btn.setMaximumWidth(30)
        self.remove_output_btn.clicked.connect(self.remove_output_port)
        outputs_btn_layout.addWidget(self.add_output_btn)
        outputs_btn_layout.addWidget(self.remove_output_btn)
        outputs_btn_layout.addStretch()
        content_layout.addLayout(outputs_btn_layout)
        
        content_layout.addStretch()
        
        self.update_btn = QPushButton("Apply Changes")
        self.update_btn.setEnabled(False)
        self.update_btn.clicked.connect(self.apply_node_changes)
        content_layout.addWidget(self.update_btn)
        
        self.status_label = QLabel("")
        self.status_label.setStyleSheet(f"color: {HOUDINI_TEXT_DIM.name()}; font-size: 10px; padding: 4px;")
        content_layout.addWidget(self.status_label)
        
        scroll.setWidget(content)
        panel_layout.addWidget(scroll)
        
        self.input_port_widgets = []
        self.output_port_widgets = []
        
        return panel
    
    def on_node_selection_changed(self, selected_nodes):
        if selected_nodes:
            self.current_selected_node = selected_nodes[0]
            self.load_node_definition()
            self.update_btn.setEnabled(True)
            self.status_label.setText(f"Editing: {self.current_selected_node.node_name}")
        else:
            self.current_selected_node = None
            self.clear_editor()
            self.update_btn.setEnabled(False)
            self.status_label.setText("")
    
    def clear_editor(self):
        self.name_edit.clear()
        self.lean_edit.clear()
        self.type_name_edit.clear()
        
        for widget_group in self.input_port_widgets:
            for widget in widget_group.values():
                widget.deleteLater()
        self.input_port_widgets.clear()
        
        for widget_group in self.output_port_widgets:
            for widget in widget_group.values():
                widget.deleteLater()
        self.output_port_widgets.clear()
    
    def load_node_definition(self):
        if not self.current_selected_node:
            return
        
        node = self.current_selected_node
        
        self.clear_editor()
        
        self.name_edit.setText(node.node_name)
        self.lean_edit.setText(node.node_type.lean_constant)
        self.type_name_edit.setText(node.node_type.name)
        
        for i, (port_name, port_type) in enumerate(node.node_type.inputs):
            port_value = ""
            if i < len(node.port_values):
                port_value = node.port_values[i]
            
            is_occupied = False
            if i < len(node.input_ports):
                is_occupied = node.input_ports[i].is_occupied()
            
            self.add_input_port_widget(port_name, port_type, port_value, is_occupied)
        
        for port_name, port_type in node.node_type.outputs:
            self.add_output_port_widget(port_name, port_type)
    
    def add_input_port_widget(self, name="", type_name="", value="", is_occupied=False):
        container = QFrame()
        container.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 4px;
            }}
        """)
        
        layout = QGridLayout(container)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)
        
        name_label = QLabel("Name:")
        name_edit = QLineEdit(name)
        name_edit.setPlaceholderText("port_name")
        layout.addWidget(name_label, 0, 0)
        layout.addWidget(name_edit, 0, 1)
        
        type_label = QLabel("Type:")
        type_edit = QLineEdit(type_name)
        type_edit.setPlaceholderText("Float")
        layout.addWidget(type_label, 1, 0)
        layout.addWidget(type_edit, 1, 1)
        
        value_label = QLabel("Value:")
        value_edit = QLineEdit(value)
        value_edit.setPlaceholderText("default value")
        value_edit.setEnabled(not is_occupied)
        layout.addWidget(value_label, 2, 0)
        layout.addWidget(value_edit, 2, 1)
        
        self.inputs_layout.addWidget(container)
        
        self.input_port_widgets.append({
            'container': container,
            'name': name_edit,
            'type': type_edit,
            'value': value_edit
        })
    
    def add_output_port_widget(self, name="", type_name=""):
        container = QFrame()
        container.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 4px;
            }}
        """)
        
        layout = QGridLayout(container)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)
        
        name_label = QLabel("Name:")
        name_edit = QLineEdit(name)
        name_edit.setPlaceholderText("port_name")
        layout.addWidget(name_label, 0, 0)
        layout.addWidget(name_edit, 0, 1)
        
        type_label = QLabel("Type:")
        type_edit = QLineEdit(type_name)
        type_edit.setPlaceholderText("Float")
        layout.addWidget(type_label, 1, 0)
        layout.addWidget(type_edit, 1, 1)
        
        self.outputs_layout.addWidget(container)
        
        self.output_port_widgets.append({
            'container': container,
            'name': name_edit,
            'type': type_edit
        })
    
    def add_input_port(self):
        self.add_input_port_widget()
    
    def remove_input_port(self):
        if self.input_port_widgets:
            widget_group = self.input_port_widgets.pop()
            for widget in widget_group.values():
                widget.deleteLater()
    
    def add_output_port(self):
        self.add_output_port_widget()
    
    def remove_output_port(self):
        if self.output_port_widgets:
            widget_group = self.output_port_widgets.pop()
            for widget in widget_group.values():
                widget.deleteLater()
    
    def apply_node_changes(self):
        if not self.current_selected_node:
            return
        
        try:
            node = self.current_selected_node
            
            node_name = self.name_edit.text().strip()
            lean_constant = self.lean_edit.text().strip()
            type_name = self.type_name_edit.text().strip()
            
            if not node_name or not type_name:
                self.status_label.setText("Error: Node name and type name required")
                self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
                return
            
            inputs = []
            port_values = []
            for widget_group in self.input_port_widgets:
                port_name = widget_group['name'].text().strip()
                port_type = widget_group['type'].text().strip()
                port_value = widget_group['value'].text().strip()
                
                if not port_name or not port_type:
                    self.status_label.setText("Error: All ports must have name and type")
                    self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
                    return
                
                inputs.append({'builtin': {'name': port_name, 'type': port_type}})
                port_values.append(port_value)
            
            outputs = []
            for widget_group in self.output_port_widgets:
                port_name = widget_group['name'].text().strip()
                port_type = widget_group['type'].text().strip()
                
                if not port_name or not port_type:
                    self.status_label.setText("Error: All ports must have name and type")
                    self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
                    return
                
                outputs.append({'builtin': {'name': port_name, 'type': port_type}})
            
            definition = {
                'name': type_name,
                'leanConstant': lean_constant,
                'exposeImplicitArgs': node.node_type.expose_implicit_args,
                'inputs': inputs,
                'outputs': outputs
            }
            
            self.editor.update_selected_node_type(definition)
            
            node.node_name = node_name
            node.header.setPlainText(node_name)
            node.port_values = port_values
            
            success_color = get_type_color('Float')
            self.status_label.setText(" Changes applied successfully")
            self.status_label.setStyleSheet(f"color: {success_color.name()}; font-size: 10px; padding: 4px;")
            
            self.load_node_definition()
            
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
    
    def on_structural_matching_changed(self, checked):
        self.editor.set_structural_matching(checked)
        status_text = "Structural type matching enabled" if checked else "Strict type name matching enabled"
        self.status_label.setText(status_text)
        self.status_label.setStyleSheet(f"color: {HOUDINI_TEXT_DIM.name()}; font-size: 10px; padding: 4px;")
    
    def on_show_implicit_changed(self, checked):
        self.editor.set_show_implicit(checked)
        status_text = "Showing implicit connections" if checked else "Hiding implicit connections"
        self.status_label.setText(status_text)
        self.status_label.setStyleSheet(f"color: {HOUDINI_TEXT_DIM.name()}; font-size: 10px; padding: 4px;")
    
    def save_graph(self):
        filename, _ = QFileDialog.getSaveFileName(self, "Save Graph", "", "JSON Files (*.json)")
        if filename:
            data = self.editor.save_to_json()
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
    
    def load_graph(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Graph", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r') as f:
                data = json.load(f)
            self.editor.load_from_json(data)
    
    def load_node_types(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Node Types", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r') as f:
                data = json.load(f)
            self.registry.load_from_json(data)
    
    def save_to_node(self):
        selected = hou.selectedNodes()
        if not selected:
            hou.ui.displayMessage("Please select a node first", severity=hou.severityType.Warning)
            return
        
        node = selected[0]
        
        if not node.parm('network'):
            parm_template = hou.StringParmTemplate('network', 'Network', 1, 
                                                   string_type=hou.stringParmType.Regular)
            parm_group = node.parmTemplateGroup()
            parm_group.append(parm_template)
            node.setParmTemplateGroup(parm_group)
        
        data = self.editor.save_to_json()
        json_str = json.dumps(data, indent=2)
        node.parm('network').set(json_str)
        
        hou.ui.displayMessage(f"Network saved to node: {node.path()}", severity=hou.severityType.Message)
    
    def load_from_node(self):
        selected = hou.selectedNodes()
        if not selected:
            hou.ui.displayMessage("Please select a node first", severity=hou.severityType.Warning)
            return
        
        node = selected[0]
        
        if not node.parm('network'):
            hou.ui.displayMessage("Selected node has no 'network' parameter", severity=hou.severityType.Warning)
            return
        
        json_str = node.parm('network').eval()
        if not json_str:
            hou.ui.displayMessage("Network parameter is empty", severity=hou.severityType.Warning)
            return
        
        try:
            data = json.loads(json_str)
            self.editor.load_from_json(data)
            hou.ui.displayMessage(f"Network loaded from node: {node.path()}", severity=hou.severityType.Message)
        except json.JSONDecodeError as e:
            hou.ui.displayMessage(f"Failed to parse network data: {e}", severity=hou.severityType.Error)


def createInterface():
    return NodeEditorWidget()
]]></script>
    <includeInPaneTabMenu menu_position="0" create_separator="false"/>
    <includeInToolbarMenu menu_position="208" create_separator="false"/>
    <help><![CDATA[]]></help>
  </interface>
</pythonPanelDocument>
