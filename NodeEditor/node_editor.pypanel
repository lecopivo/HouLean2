<?xml version="1.0" encoding="UTF-8"?>
<pythonPanelDocument>
  <!-- This file contains definitions of Python interfaces and the
 interfaces menu.  It should not be hand-edited when it is being
 used by the application.  Note, that two definitions of the
 same interface or of the interfaces menu are not allowed
 in a single file. -->
  <interface name="Lean Node Editor" label="Lean Node Editor" icon="MISC_python" showNetworkNavigationBar="false" help_url="">
    <script><![CDATA["""
Houdini Node Editor Python Pane with Dynamic Typing and Custom Port Types
To use: In Houdini, create a new Python Panel and paste this code
"""

import json
import hou
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGraphicsView, 
                               QGraphicsScene, QGraphicsItem, QGraphicsRectItem,
                               QGraphicsTextItem, QPushButton, QFileDialog, 
                               QGraphicsPathItem, QInputDialog, QLineEdit, QMenu, 
                               QLabel, QFrame, QTextEdit, QSplitter, QCheckBox)
from PySide6.QtCore import Qt, QRectF, QPointF, QTimer
from PySide6.QtGui import QPen, QBrush, QColor, QPainterPath, QFont, QPainter, QPainterPathStroker, QLinearGradient
from PySide6.QtWidgets import QStyle

# Houdini color scheme
HOUDINI_BG = QColor(58, 58, 58)
HOUDINI_BG_DARK = QColor(38, 38, 38)
HOUDINI_BG_LIGHT = QColor(68, 68, 68)
HOUDINI_NODE_BG = QColor(48, 48, 48)
HOUDINI_NODE_BORDER = QColor(28, 28, 28)
HOUDINI_NODE_SELECTED = QColor(248, 156, 40)
HOUDINI_TEXT = QColor(220, 220, 220)
HOUDINI_TEXT_DIM = QColor(150, 150, 150)
HOUDINI_GRID_FINE = QColor(50, 50, 50)
HOUDINI_GRID_THICK = QColor(60, 60, 60)
HOUDINI_ERROR = QColor(220, 60, 60)


def get_type_color(type_name):
    """Get color for a port type"""
    colors = {
        'Float': QColor(120, 220, 120),
        'Vector3': QColor(100, 180, 255),
        'Particle': QColor(255, 160, 100),
        'Character': QColor(200, 120, 200),
    }
    return colors.get(type_name, QColor(180, 180, 180))


class PortType:
    def __init__(self, name, subports=None):
        self.name = name
        self.subports = subports or []


class NodeType:
    def __init__(self, name, inputs, outputs, custom_port_types=None):
        self.name = name
        self.inputs = inputs
        self.outputs = outputs
        # Store custom port types defined inline in this node type
        self.custom_port_types = custom_port_types or {}


class NodeTypeRegistry:
    def __init__(self):
        self.node_types = {}
        self.port_types = {}
    
    def load_from_json(self, json_data):
        data = json.loads(json_data) if isinstance(json_data, str) else json_data
        
        for type_name, type_def in data.get('port_types', {}).items():
            subports = [(sp['name'], sp['type']) for sp in type_def.get('subports', [])]
            self.port_types[type_name] = PortType(type_name, subports)
        
        for node_def in data.get('node_types', []):
            custom_port_types = {}
            
            # Helper to recursively extract custom port types
            def extract_custom_types(port_type_def):
                """Recursively extract all custom port types from a definition"""
                if isinstance(port_type_def, dict):
                    custom_type_name = port_type_def['portType']
                    subports = []
                    
                    for sp in port_type_def.get('subports', []):
                        sp_name = sp['name']
                        sp_type = sp['type']
                        
                        # Recursively process nested custom types
                        if isinstance(sp_type, dict):
                            extract_custom_types(sp_type)
                            subports.append((sp_name, sp_type['portType']))
                        else:
                            subports.append((sp_name, sp_type))
                    
                    custom_port_types[custom_type_name] = PortType(custom_type_name, subports)
            
            # Parse inputs and extract custom port types
            inputs = []
            for inp in node_def.get('inputs', []):
                port_name = inp['name']
                port_type = inp['type']
                
                if isinstance(port_type, dict):
                    extract_custom_types(port_type)
                    inputs.append((port_name, port_type['portType']))
                else:
                    inputs.append((port_name, port_type))
            
            # Parse outputs and extract custom port types
            outputs = []
            for out in node_def.get('outputs', []):
                port_name = out['name']
                port_type = out['type']
                
                if isinstance(port_type, dict):
                    extract_custom_types(port_type)
                    outputs.append((port_name, port_type['portType']))
                else:
                    outputs.append((port_name, port_type))
            
            self.node_types[node_def['name']] = NodeType(node_def['name'], inputs, outputs, custom_port_types)
    
    def get_port_type(self, type_name, node_type=None):
        """Get port type, checking node-specific custom types first"""
        if node_type and type_name in node_type.custom_port_types:
            return node_type.custom_port_types[type_name]
        return self.port_types.get(type_name)
    
    def get_node_type(self, type_name):
        return self.node_types.get(type_name)


class SubportWidget(QGraphicsItem):
    PORT_RADIUS = 5
    SUBPORT_SPACING = 22
    
    def __init__(self, name, type_name, is_input, parent_port, registry, node_type=None):
        super().__init__()
        self.name = name
        self.type_name = type_name
        self.is_input = is_input
        self.parent_port = parent_port
        self.node = parent_port.node
        self.registry = registry
        self.node_type = node_type or (parent_port.node_type if hasattr(parent_port, 'node_type') else None)
        self.connections = []
        self.hover_active = False
        
        self.subport_widgets = []
        self.expanded = False
        self.expansion_widget = None
        
        port_type = registry.get_port_type(type_name, self.node_type)
        self.subport_defs = []
        if port_type and port_type.subports:
            self.subport_defs = port_type.subports
        
        # For structural comparison
        self.allow_structural_matching = True  # Will be set by view
        
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
    
    def boundingRect(self):
        return QRectF(-self.PORT_RADIUS, -self.PORT_RADIUS, 
                     self.PORT_RADIUS * 2, self.PORT_RADIUS * 2)
    
    def shape(self):
        path = QPainterPath()
        radius = self.PORT_RADIUS + 5
        path.addEllipse(QPointF(0, 0), radius, radius)
        return path
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        color = get_type_color(self.type_name)
        
        if self.has_connection():
            painter.setBrush(QBrush(color))
        else:
            painter.setBrush(QBrush(color.darker(180)))
        
        border_width = 2.5 if self.hover_active else 1.5
        painter.setPen(QPen(color.darker(120), border_width))
        painter.drawEllipse(self.boundingRect())
    
    def get_full_path(self):
        return f"{self.parent_port.get_full_path()}.{self.name}"
    
    def get_index_path(self):
        """Get the index path [port_idx, subport_idx, ...]"""
        path = []
        current = self
        while hasattr(current, 'parent_port') and current.parent_port:
            parent = current.parent_port
            if hasattr(parent, 'subport_widgets'):
                idx = parent.subport_widgets.index(current) if current in parent.subport_widgets else -1
                path.insert(0, idx)
            current = parent
        
        if hasattr(current, 'node'):
            ports = current.node.input_ports if current.is_input else current.node.output_ports
            if current in ports:
                path.insert(0, ports.index(current))
        
        return path
    
    def has_connection(self):
        if self.connections:
            return True
        for subport in self.subport_widgets:
            if subport.has_connection():
                return True
        return False
    
    def is_connectable_to(self, other_port):
        if self.is_input == other_port.is_input:
            return False
        if self.node == other_port.node:
            return False
        
        # Check type compatibility
        if not self.types_are_compatible(other_port):
            return False
        
        input_port = self if self.is_input else other_port
        if input_port.is_occupied():
            return False
        return True
    
    def types_are_compatible(self, other_port):
        """Check if types are compatible (without other connection checks)"""
        if self.allow_structural_matching:
            return self._types_structurally_match(other_port)
        else:
            # Strict name matching
            return self.type_name == other_port.type_name
    
    def _types_structurally_match(self, other_port):
        """Check if two ports have matching structure"""
        # If names match exactly, they're compatible
        if self.type_name == other_port.type_name:
            return True
        
        # Get port type definitions
        my_port_type = self.registry.get_port_type(self.type_name, self.node_type)
        other_port_type = self.registry.get_port_type(other_port.type_name, 
                                                       other_port.node_type if hasattr(other_port, 'node_type') else None)
        
        # If both are leaf types (no subports), they must have the same name
        if not my_port_type or not my_port_type.subports:
            if not other_port_type or not other_port_type.subports:
                return self.type_name == other_port.type_name
            return False
        
        if not other_port_type or not other_port_type.subports:
            return False
        
        # Both have subports - compare structures
        my_subports = my_port_type.subports
        other_subports = other_port_type.subports
        
        # Must have same number of subports
        if len(my_subports) != len(other_subports):
            return False
        
        # Check each subport matches (name and type structure)
        for (my_name, my_type), (other_name, other_type) in zip(my_subports, other_subports):
            # Subport names must match
            if my_name != other_name:
                return False
            
            # Recursively check subport type compatibility
            # Create temporary subport widgets to check their structure
            temp_my_subport = SubportWidget(my_name, my_type, self.is_input, self, self.registry, self.node_type)
            temp_other_subport = SubportWidget(other_name, other_type, other_port.is_input, other_port, 
                                               self.registry, other_port.node_type if hasattr(other_port, 'node_type') else None)
            
            if not temp_my_subport._types_structurally_match(temp_other_subport):
                return False
        
        return True
    
    def is_occupied(self):
        if self.connections:
            return True
        current = self.parent_port
        while current:
            if current.connections:
                return True
            current = current.parent_port if hasattr(current, 'parent_port') else None
        return self._has_connected_descendant()
    
    def _has_connected_descendant(self):
        for subport in self.subport_widgets:
            if subport.connections or subport._has_connected_descendant():
                return True
        return False
    
    def get_scene_pos(self):
        return self.scenePos()
    
    def expand(self):
        if not self.subport_defs or self.expanded:
            return
        
        self.expanded = True
        original_scene_pos = self.get_scene_pos()
        
        self.subport_widgets = []
        for subport_name, subport_type in self.subport_defs:
            subport = SubportWidget(subport_name, subport_type, self.is_input, self, self.registry, self.node_type)
            subport.allow_structural_matching = self.allow_structural_matching
            self.subport_widgets.append(subport)
        
        self.expansion_widget = SubportExpansion(self, self.subport_widgets, self.is_input)
        self.expansion_widget.setParentItem(self.node)
        
        node_pos = self.node.mapFromItem(self, 0, 0)
        if self.is_input:
            self.expansion_widget.setPos(node_pos.x() - 2*SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        else:
            self.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        
        self._update_parent_expansions()
        
        if self.node:
            self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def _update_parent_expansions(self):
        current = self.parent_port
        while current:
            if hasattr(current, 'expansion_widget') and current.expansion_widget:
                current.expansion_widget._update_subport_positions()
            if hasattr(current, 'parent_port'):
                current = current.parent_port
            else:
                break
    
    def collapse(self):
        if not self.expanded:
            return
        
        if self.node and self.node.scene():
            view = self.node.scene().views()[0] if self.node.scene().views() else None
            if view and hasattr(view, '_is_port_locked') and view._is_port_locked(self):
                return
        
        has_connections = any(subport.has_connection() for subport in self.subport_widgets)
        
        if not has_connections:
            original_scene_pos = self.get_scene_pos()
            self.expanded = False
            
            for subport in self.subport_widgets[:]:
                if subport.expanded:
                    subport.collapse()
            
            if self.expansion_widget:
                scene = self.scene()
                if scene and self.expansion_widget.scene() == scene:
                    scene.removeItem(self.expansion_widget)
                self.expansion_widget = None
            
            self.subport_widgets = []
            self._update_parent_expansions()
            
            if self.node:
                self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def hoverEnterEvent(self, event):
        self.hover_active = True
        self.update()
        if self.is_input and self.is_occupied():
            super().hoverEnterEvent(event)
            return
        if self.subport_defs and not self.expanded:
            self.expand()
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        self.hover_active = False
        self.update()
        QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.hover_active:
            return
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return
        if self._is_any_expansion_hovered():
            return
        self.collapse()
    
    def _is_any_expansion_hovered(self):
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return True
        for subport in self.subport_widgets:
            if subport.hover_active:
                return True
            if subport._is_any_expansion_hovered():
                return True
        return False


class PortWidget(QGraphicsItem):
    PORT_RADIUS = 6
    SUBPORT_SPACING = 22
    
    def __init__(self, name, type_name, registry, is_input, parent_port=None, node=None, node_type=None):
        super().__init__()
        self.name = name
        self.type_name = type_name
        self.registry = registry
        self.is_input = is_input
        self.parent_port = parent_port
        self.node = node
        self.node_type = node_type
        self.subport_widgets = []
        self.expanded = False
        self.expansion_widget = None
        self.connections = []
        self.hover_active = False
        
        port_type = registry.get_port_type(type_name, self.node_type)
        self.subport_defs = []
        if port_type and port_type.subports:
            self.subport_defs = port_type.subports
        
        # For structural comparison
        self.allow_structural_matching = True  # Will be set by view
        
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
    
    def boundingRect(self):
        return QRectF(-self.PORT_RADIUS, -self.PORT_RADIUS, 
                     self.PORT_RADIUS * 2, self.PORT_RADIUS * 2)
    
    def shape(self):
        path = QPainterPath()
        radius = self.PORT_RADIUS + 5
        path.addEllipse(QPointF(0, 0), radius, radius)
        return path
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        color = get_type_color(self.type_name)
        
        if self.has_connection():
            painter.setBrush(QBrush(color))
        else:
            painter.setBrush(QBrush(color.darker(180)))
        
        border_width = 2.5 if self.hover_active else 1.5
        painter.setPen(QPen(color.darker(120), border_width))
        painter.drawEllipse(self.boundingRect())
    
    def get_full_path(self):
        if self.parent_port:
            return f"{self.parent_port.get_full_path()}.{self.name}"
        return self.name
    
    def get_index_path(self):
        """Get the index path [port_idx, subport_idx, ...]"""
        ports = self.node.input_ports if self.is_input else self.node.output_ports
        if self in ports:
            return [ports.index(self)]
        return []
    
    def has_connection(self):
        if self.connections:
            return True
        for subport in self.subport_widgets:
            if subport.has_connection():
                return True
        return False
    
    def is_connectable_to(self, other_port):
        if self.is_input == other_port.is_input:
            return False
        if self.node == other_port.node:
            return False
        
        # Check type compatibility
        if not self.types_are_compatible(other_port):
            return False
        
        input_port = self if self.is_input else other_port
        if input_port.is_occupied():
            return False
        return True
    
    def types_are_compatible(self, other_port):
        """Check if types are compatible (without other connection checks)"""
        if self.allow_structural_matching:
            return self._types_structurally_match(other_port)
        else:
            # Strict name matching
            return self.type_name == other_port.type_name
    
    def _types_structurally_match(self, other_port):
        """Check if two ports have matching structure"""
        # If names match exactly, they're compatible
        if self.type_name == other_port.type_name:
            return True
        
        # Get port type definitions
        my_port_type = self.registry.get_port_type(self.type_name, self.node_type)
        other_port_type = self.registry.get_port_type(other_port.type_name, 
                                                       other_port.node_type if hasattr(other_port, 'node_type') else None)
        
        # If both are leaf types (no subports), they must have the same name
        if not my_port_type or not my_port_type.subports:
            if not other_port_type or not other_port_type.subports:
                return self.type_name == other_port.type_name
            return False
        
        if not other_port_type or not other_port_type.subports:
            return False
        
        # Both have subports - compare structures
        my_subports = my_port_type.subports
        other_subports = other_port_type.subports
        
        # Must have same number of subports
        if len(my_subports) != len(other_subports):
            return False
        
        # Check each subport matches (name and type structure)
        for (my_name, my_type), (other_name, other_type) in zip(my_subports, other_subports):
            # Subport names must match
            if my_name != other_name:
                return False
            
            # Recursively check subport type compatibility
            # Create temporary port widgets to check their structure
            temp_my_port = PortWidget(my_name, my_type, self.registry, self.is_input, None, self.node, self.node_type)
            temp_other_port = PortWidget(other_name, other_type, self.registry, other_port.is_input, None, 
                                         other_port.node, other_port.node_type if hasattr(other_port, 'node_type') else None)
            
            if not temp_my_port._types_structurally_match(temp_other_port):
                return False
        
        return True
    
    def is_occupied(self):
        if self.connections:
            return True
        current = self.parent_port
        while current:
            if current.connections:
                return True
            current = current.parent_port
        return self._has_connected_descendant()
    
    def _has_connected_descendant(self):
        for subport in self.subport_widgets:
            if subport.connections or subport._has_connected_descendant():
                return True
        return False
    
    def get_scene_pos(self):
        return self.scenePos()
    
    def expand(self):
        if not self.subport_defs or self.expanded:
            return
        
        self.expanded = True
        original_scene_pos = self.get_scene_pos()
        
        self.subport_widgets = []
        for subport_name, subport_type in self.subport_defs:
            subport = SubportWidget(subport_name, subport_type, self.is_input, self, self.registry, self.node_type)
            subport.allow_structural_matching = self.allow_structural_matching
            self.subport_widgets.append(subport)
        
        self.expansion_widget = SubportExpansion(self, self.subport_widgets, self.is_input)
        self.expansion_widget.setParentItem(self.node)
        
        node_pos = self.node.mapFromItem(self, 0, 0)
        if self.is_input:
            self.expansion_widget.setPos(node_pos.x() - 2*SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        else:
            self.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        
        self._update_parent_expansions()
        
        if self.node:
            self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def _update_parent_expansions(self):
        current = self.parent_port
        while current:
            if hasattr(current, 'expansion_widget') and current.expansion_widget:
                current.expansion_widget._update_subport_positions()
            if hasattr(current, 'parent_port'):
                current = current.parent_port
            else:
                break
    
    def collapse(self):
        if not self.expanded:
            return
        
        if self.node and self.node.scene():
            view = self.node.scene().views()[0] if self.node.scene().views() else None
            if view and hasattr(view, '_is_port_locked') and view._is_port_locked(self):
                return
        
        has_connections = any(subport.has_connection() for subport in self.subport_widgets)
        
        if not has_connections:
            original_scene_pos = self.get_scene_pos()
            self.expanded = False
            
            for subport in self.subport_widgets[:]:
                if subport.expanded:
                    subport.collapse()
            
            if self.expansion_widget:
                scene = self.scene()
                if scene and self.expansion_widget.scene() == scene:
                    scene.removeItem(self.expansion_widget)
                self.expansion_widget = None
            
            self.subport_widgets = []
            
            if self.node:
                self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def hoverEnterEvent(self, event):
        self.hover_active = True
        self.update()
        if self.is_input and self.is_occupied():
            super().hoverEnterEvent(event)
            return
        if self.subport_defs and not self.expanded:
            self.expand()
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        self.hover_active = False
        self.update()
        QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.hover_active:
            return
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return
        if self._is_any_expansion_hovered():
            return
        self.collapse()
    
    def _is_any_expansion_hovered(self):
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return True
        for subport in self.subport_widgets:
            if subport.hover_active:
                return True
            if subport._is_any_expansion_hovered():
                return True
        return False


class SubportExpansion(QGraphicsRectItem):
    WIDTH = 12
    HOVER_MARGIN = 30
    
    def __init__(self, parent_port, subports, is_input):
        super().__init__()
        self.parent_port = parent_port
        self.subports = subports
        self.is_input = is_input
        self.labels = []
        
        self.setAcceptHoverEvents(True)
        
        height = len(subports) * PortWidget.SUBPORT_SPACING
        
        # Position rectangle based on port direction
        if is_input:
            # For input: rectangle extends to the right (away from node)
            self.setRect(0, 0, self.WIDTH, height)
        else:
            # For output: rectangle extends to the left (toward node, away from port)
            self.setRect(-self.WIDTH, 0, self.WIDTH, height)
        
        self.setBrush(QBrush(HOUDINI_BG_LIGHT))
        self.setPen(QPen(HOUDINI_NODE_BORDER, 1))
        
        self._update_subport_positions()
    
    def _update_subport_positions(self):
        current_y = PortWidget.SUBPORT_SPACING // 2
        
        for i, subport in enumerate(self.subports):
            if subport.parentItem() != self:
                subport.setParentItem(self)
            
            if self.is_input:
                # For input: place subports at the right edge of expansion (away from main port)
                subport.setPos(self.WIDTH, current_y)
            else:
                # For output: place subports at the left edge of expansion (away from main port)
                subport.setPos(0, current_y)
            
            # Create or update label
            if i < len(self.labels):
                label = self.labels[i]
            else:
                label = QGraphicsTextItem(subport.name, self)
                label.setDefaultTextColor(HOUDINI_TEXT)
                font = QFont("Arial", 9)
                label.setFont(font)
                self.labels.append(label)
            
            # Position labels consistently for both input and output
            node = subport.node
            if self.is_input:
                # For input: label to the right of the subport
                label.setPos(self.WIDTH + PortWidget.PORT_RADIUS * 2 + 5, current_y - 8)
            else:
                # For output: label to the left of the subport
                label_width = label.boundingRect().width()
                label.setPos(-PortWidget.PORT_RADIUS * 2 - label_width - 5, current_y - 8)
            
            # Update nested expansion positions
            if subport.expanded and subport.expansion_widget:
                node_pos = subport.node.mapFromItem(subport, 0, 0)
                if self.is_input:
                    # Input subport expansion goes further right
                    subport.expansion_widget.setPos(node_pos.x() - 2*SubportExpansion.WIDTH,
                                                   node_pos.y() + subport.PORT_RADIUS)
                else:
                    # Output subport expansion goes further left
                    subport.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH,
                                                   node_pos.y() + subport.PORT_RADIUS)
            
            current_y += PortWidget.SUBPORT_SPACING
            if subport.expanded and subport.subport_widgets:
                current_y += self._calculate_subport_expansion_height(subport)
        
        new_height = current_y - PortWidget.SUBPORT_SPACING // 2
        
        # Update rectangle size based on direction
        if self.is_input:
            self.setRect(self.WIDTH, 0, self.WIDTH, new_height)
        else:
            self.setRect(-self.WIDTH, 0, self.WIDTH, new_height)
    
    def _calculate_subport_expansion_height(self, subport):
        if not subport.expanded or not subport.subport_widgets:
            return 0
        
        height = 0
        for nested in subport.subport_widgets:
            height += PortWidget.SUBPORT_SPACING
            if nested.expanded and nested.subport_widgets:
                height += self._calculate_subport_expansion_height(nested)
        return height
    
    def shape(self):
        path = QPainterPath()
        rect = self.rect()
        if self.is_input:
            # Input: expand hover area to the right
            expanded = QRectF(rect.x() - 5, 
                            rect.y() - 5, 
                            rect.width() + self.HOVER_MARGIN + 100,
                            rect.height() + 10)
        else:
            # Output: expand hover area to the left
            expanded = QRectF(rect.x() - self.HOVER_MARGIN - 100,
                            rect.y() - 5, 
                            rect.width() + self.HOVER_MARGIN + 100, 
                            rect.height() + 10)
        path.addRect(expanded)
        return path
    
    def hoverLeaveEvent(self, event):
        if not self.isUnderMouse():
            QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.isUnderMouse():
            return
        if self.parent_port.hover_active:
            return
        if self.parent_port._is_any_expansion_hovered():
            return
        self.parent_port.collapse()
        

class Connection(QGraphicsPathItem):
    def __init__(self, output_port, input_port, scene, output_index_path=None, input_index_path=None):
        super().__init__()
        self.output_port = output_port
        self.input_port = input_port
        self.output_node = output_port.node if output_port else None
        self.input_node = input_port.node if input_port else None
        
        # Store index paths for reconnection
        self.output_index_path = output_index_path or (output_port.get_index_path() if output_port else [])
        self.input_index_path = input_index_path or (input_port.get_index_path() if input_port else [])
        
        # Store relative positions for invalid connections
        if self.output_node and output_port:
            self.output_relative_y = output_port.get_scene_pos().y() - self.output_node.pos().y()
        else:
            self.output_relative_y = 0
            
        if self.input_node and input_port:
            self.input_relative_y = input_port.get_scene_pos().y() - self.input_node.pos().y()
        else:
            self.input_relative_y = 0
        
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        # Don't allow moving wires - they're determined by node positions
        self.setFlag(QGraphicsItem.ItemIsMovable, False)
        
        # Determine connection validity
        self.output_valid = output_port is not None
        self.input_valid = input_port is not None
        
        color = get_type_color(output_port.type_name) if output_port else HOUDINI_ERROR
        self.normal_pen = QPen(color, 2.5)
        self.selected_pen = QPen(HOUDINI_NODE_SELECTED, 3.5)
        self.invalid_pen = QPen(HOUDINI_ERROR, 2.5)
        
        # Shadow pen for selection
        self.shadow_pen = QPen(QColor(255, 255, 255, 180), 6.0)
        
        if output_port:
            output_port.connections.append(self)
        if input_port:
            input_port.connections.append(self)
        
        if output_port and isinstance(output_port, SubportWidget):
            self._expand_hierarchy(output_port)
        if input_port and isinstance(input_port, SubportWidget):
            self._expand_hierarchy(input_port)
        
        self.update_path()
    
    def is_valid(self):
        """Check if connection is valid (both ends exist and types match)"""
        if not (self.output_valid and self.input_valid):
            return False
        # Check type compatibility
        if self.output_port and self.input_port:
            return self.output_port.type_name == self.input_port.type_name
        return False
    
    def has_type_mismatch(self):
        """Check if both ends exist but types don't match"""
        return (self.output_valid and self.input_valid and 
                self.output_port.type_name != self.input_port.type_name)
    
    def boundingRect(self):
        """Override to prevent default selection border"""
        # Add a bit of padding for the shadow
        if self.isSelected():
            return self.path().boundingRect().adjusted(-4, -4, 4, 4)
        return self.path().boundingRect()
    
    def shape(self):
        stroker = QPainterPathStroker()
        stroker.setWidth(12)
        stroker.setCapStyle(Qt.RoundCap)
        return stroker.createStroke(self.path())
    
    def _expand_hierarchy(self, port):
        if isinstance(port, SubportWidget):
            try:
                current = port.parent_port
                while current:
                    _ = current.scene()
                    if not current.expanded:
                        current.expand()
                    current = current.parent_port if hasattr(current, 'parent_port') else None
            except RuntimeError:
                pass
    
    def update_path(self):
        try:
            # Get positions
            if self.output_port:
                start = self.output_port.get_scene_pos()
            elif self.output_node:
                # Use relative position for invalid output
                start = QPointF(self.output_node.pos().x() + self.output_node.rect().width(),
                              self.output_node.pos().y() + self.output_relative_y)
            else:
                return
            
            if self.input_port:
                end = self.input_port.get_scene_pos()
            elif self.input_node:
                # Use relative position for invalid input
                end = QPointF(self.input_node.pos().x(),
                            self.input_node.pos().y() + self.input_relative_y)
            else:
                return
            
            path = QPainterPath()
            path.moveTo(start)
            
            ctrl_offset = abs(end.x() - start.x()) * 0.5
            ctrl1 = QPointF(start.x() + ctrl_offset, start.y())
            ctrl2 = QPointF(end.x() - ctrl_offset, end.y())
            path.cubicTo(ctrl1, ctrl2, end)
            
            self.setPath(path)
        except RuntimeError:
            if self.scene():
                self.scene().removeItem(self)
    
    def remove(self):
        try:
            if self.output_port and self in self.output_port.connections:
                self.output_port.connections.remove(self)
        except (RuntimeError, AttributeError):
            pass
            
        try:
            if self.input_port and self in self.input_port.connections:
                self.input_port.connections.remove(self)
        except (RuntimeError, AttributeError):
            pass
        
        def try_collapse_hierarchy(port):
            try:
                if isinstance(port, SubportWidget):
                    port.collapse()
                    if hasattr(port, 'parent_port') and port.parent_port:
                        try_collapse_hierarchy(port.parent_port)
                elif isinstance(port, PortWidget):
                    port.collapse()
            except RuntimeError:
                pass
        
        if self.output_port:
            try:
                try_collapse_hierarchy(self.output_port)
            except (RuntimeError, AttributeError):
                pass
            
        if self.input_port:
            try:
                try_collapse_hierarchy(self.input_port)
            except (RuntimeError, AttributeError):
                pass
        
        if self.scene():
            self.scene().removeItem(self)
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw shadow if selected
        if self.isSelected():
            painter.setPen(self.shadow_pen)
            painter.drawPath(self.path())
        
        # Draw the main wire
        if self.has_type_mismatch():
            # Type mismatch - gradient from output color to input color
            output_color = get_type_color(self.output_port.type_name)
            input_color = get_type_color(self.input_port.type_name)
            gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
            gradient.setColorAt(0, output_color)
            gradient.setColorAt(1, input_color)
            pen = QPen(QBrush(gradient), 2.5)
        elif not self.is_valid():
            # Invalid connection (missing port)
            if self.output_valid and not self.input_valid:
                # Valid output, invalid input - gradient from normal to red
                gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
                gradient.setColorAt(0, self.normal_pen.color())
                gradient.setColorAt(1, HOUDINI_ERROR)
                pen = QPen(QBrush(gradient), 2.5)
            elif not self.output_valid and self.input_valid:
                # Invalid output, valid input - gradient from red to normal
                gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
                gradient.setColorAt(0, HOUDINI_ERROR)
                gradient.setColorAt(1, self.normal_pen.color())
                pen = QPen(QBrush(gradient), 2.5)
            else:
                # Both invalid
                pen = self.invalid_pen
        else:
            pen = self.normal_pen
        
        painter.setPen(pen)
        painter.drawPath(self.path())
    
    def expand_connection(self):
        """Expand this connection into subport connections"""
        if not self.output_port or not self.input_port:
            return []
        
        if not self.output_port.subport_defs or not self.input_port.subport_defs:
            return []
        
        if not self.output_port.expanded:
            self.output_port.expand()
        if not self.input_port.expanded:
            self.input_port.expand()
        
        output_subports = {sp.name: sp for sp in self.output_port.subport_widgets}
        input_subports = {sp.name: sp for sp in self.input_port.subport_widgets}
        
        new_connections = []
        for name in output_subports:
            if name in input_subports:
                out_sp = output_subports[name]
                in_sp = input_subports[name]
                # Check type compatibility only (ignore occupation checks during expansion)
                if out_sp.types_are_compatible(in_sp):
                    conn = Connection(out_sp, in_sp, self.scene())
                    if self.scene():
                        self.scene().addItem(conn)
                    new_connections.append(conn)
        
        self.remove()
        return new_connections
    
    def reconnect(self):
        """Try to reconnect to ports based on stored index paths"""
        # Remove from old port lists if they exist
        if self.output_port and self in self.output_port.connections:
            self.output_port.connections.remove(self)
        if self.input_port and self in self.input_port.connections:
            self.input_port.connections.remove(self)
        
        # Try to find new ports
        self.output_port = self._find_port_by_index(self.output_node, self.output_index_path, False)
        self.input_port = self._find_port_by_index(self.input_node, self.input_index_path, True)
        
        # Update validity state
        self.output_valid = self.output_port is not None
        self.input_valid = self.input_port is not None
        
        # Update relative positions for current node state
        if self.output_node and self.output_port:
            self.output_relative_y = self.output_port.get_scene_pos().y() - self.output_node.pos().y()
        elif self.output_node:
            # Keep the old relative position for invalid connections
            pass
            
        if self.input_node and self.input_port:
            self.input_relative_y = self.input_port.get_scene_pos().y() - self.input_node.pos().y()
        elif self.input_node:
            # Keep the old relative position for invalid connections
            pass
        
        # Update pen color based on new port type
        if self.output_port:
            color = get_type_color(self.output_port.type_name)
            self.normal_pen = QPen(color, 2.5)
        elif self.input_port:
            # If no output port, use input port color
            color = get_type_color(self.input_port.type_name)
            self.normal_pen = QPen(color, 2.5)
        
        # Add to new port connection lists
        if self.output_port and self not in self.output_port.connections:
            self.output_port.connections.append(self)
        if self.input_port and self not in self.input_port.connections:
            self.input_port.connections.append(self)
        
        # Expand hierarchies if needed
        if self.output_port and isinstance(self.output_port, SubportWidget):
            self._expand_hierarchy(self.output_port)
        if self.input_port and isinstance(self.input_port, SubportWidget):
            self._expand_hierarchy(self.input_port)
        
        # Update the visual path
        self.update_path()
        self.update()
    
    def _find_port_by_index(self, node, index_path, is_input):
        """Find port by index path [port_idx, subport_idx, ...]"""
        if not node or not index_path:
            return None
        
        ports = node.input_ports if is_input else node.output_ports
        
        if index_path[0] >= len(ports):
            return None
        
        current_port = ports[index_path[0]]
        
        for idx in index_path[1:]:
            if not current_port.expanded:
                current_port.expand()
            
            if idx >= len(current_port.subport_widgets):
                return None
            
            current_port = current_port.subport_widgets[idx]
        
        return current_port


class NodeWidget(QGraphicsRectItem):
    MIN_WIDTH = 180
    MIN_HEIGHT = 60
    PORT_SPACING = 28
    HEADER_HEIGHT = 32
    
    def __init__(self, node_type, registry, name=None):
        super().__init__()
        self.node_type = node_type
        self.registry = registry
        self.node_name = name or node_type.name
        self.input_ports = []
        self.output_ports = []
        
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        
        self.setBrush(QBrush(HOUDINI_NODE_BG))
        self.setPen(QPen(HOUDINI_NODE_BORDER, 2))
        
        self.header = QGraphicsTextItem(self.node_name, self)
        self.header.setDefaultTextColor(HOUDINI_TEXT)
        font = QFont("Arial", 10, QFont.Bold)
        self.header.setFont(font)
        self.header.setPos(8, 6)
        
        self._create_ports()
        self.adjust_size_for_expansion()
    
    def _create_ports(self):
        for i, (port_name, port_type) in enumerate(self.node_type.inputs):
            port = PortWidget(port_name, port_type, self.registry, True, None, self, self.node_type)
            port.setParentItem(self)
            self.input_ports.append(port)
            
            label = QGraphicsTextItem(port_name, self)
            label.setDefaultTextColor(HOUDINI_TEXT)
            font = QFont("Arial", 9)
            label.setFont(font)
            port.label = label
        
        for i, (port_name, port_type) in enumerate(self.node_type.outputs):
            port = PortWidget(port_name, port_type, self.registry, False, None, self, self.node_type)
            port.setParentItem(self)
            self.output_ports.append(port)
            
            label = QGraphicsTextItem(port_name, self)
            label.setDefaultTextColor(HOUDINI_TEXT)
            font = QFont("Arial", 9)
            label.setFont(font)
            port.label = label
    
    def change_type(self, new_type_name, custom_definition=None):
        """Change this node to a different type, preserving connections where possible
        
        Args:
            new_type_name: Name for the new type
            custom_definition: Optional dict with custom node type definition
        """
        if custom_definition:
            # Create a temporary NodeType from the custom definition
            custom_port_types = {}
            
            # Helper to recursively extract custom port types
            def extract_custom_types(port_type_def):
                """Recursively extract all custom port types from a definition"""
                if isinstance(port_type_def, dict):
                    custom_type_name = port_type_def['portType']
                    subports = []
                    
                    for sp in port_type_def.get('subports', []):
                        sp_name = sp['name']
                        sp_type = sp['type']
                        
                        # Recursively process nested custom types
                        if isinstance(sp_type, dict):
                            extract_custom_types(sp_type)
                            subports.append((sp_name, sp_type['portType']))
                        else:
                            subports.append((sp_name, sp_type))
                    
                    custom_port_types[custom_type_name] = PortType(custom_type_name, subports)
            
            # Parse inputs and extract custom port types
            inputs = []
            for inp in custom_definition.get('inputs', []):
                port_name = inp['name']
                port_type = inp['type']
                
                if isinstance(port_type, dict):
                    extract_custom_types(port_type)
                    inputs.append((port_name, port_type['portType']))
                else:
                    inputs.append((port_name, port_type))
            
            # Parse outputs and extract custom port types
            outputs = []
            for out in custom_definition.get('outputs', []):
                port_name = out['name']
                port_type = out['type']
                
                if isinstance(port_type, dict):
                    extract_custom_types(port_type)
                    outputs.append((port_name, port_type['portType']))
                else:
                    outputs.append((port_name, port_type))
            
            new_type = NodeType(custom_definition['name'], inputs, outputs, custom_port_types)
        else:
            new_type = self.registry.get_node_type(new_type_name)
            if not new_type:
                return
        
        # Get the view to access all connections
        view = None
        if self.scene() and self.scene().views():
            view = self.scene().views()[0]
        
        # Collect all connections that reference this node
        all_connections = []
        if view:
            for conn in view.connections:
                if conn.output_node == self or conn.input_node == self:
                    all_connections.append(conn)
        
        # Remove connections from old ports' lists
        for port in self.input_ports + self.output_ports:
            self._remove_port_connections(port)
        
        # Clear old ports completely
        for port in self.input_ports + self.output_ports:
            self._clear_port_completely(port)
        self.input_ports.clear()
        self.output_ports.clear()
        
        # Update type and name
        self.node_type = new_type
        self.node_name = new_type.name
        self.header.setPlainText(self.node_name)
        
        # Create new ports
        self._create_ports()
        self.adjust_size_for_expansion()
        
        # Update structural matching for new ports
        if self.scene() and self.scene().views():
            view = self.scene().views()[0]
            if hasattr(view, '_update_node_ports_matching'):
                view._update_node_ports_matching(self)
        
        # Try to reconnect all connections
        for conn in all_connections:
            conn.reconnect()
    
    def _remove_port_connections(self, port):
        """Remove connections from port's list but don't delete from scene"""
        for subport in port.subport_widgets[:]:
            self._remove_port_connections(subport)
        port.connections.clear()
    
    def _clear_port_completely(self, port):
        """Completely remove a port and all its visual elements"""
        # Clear subports first
        for subport in port.subport_widgets[:]:
            self._clear_port_completely(subport)
        
        # Remove expansion widget
        if hasattr(port, 'expansion_widget') and port.expansion_widget:
            if port.expansion_widget.scene():
                port.expansion_widget.scene().removeItem(port.expansion_widget)
            port.expansion_widget = None
        
        # Remove label
        if hasattr(port, 'label') and port.label:
            if port.label.scene():
                port.label.scene().removeItem(port.label)
            port.label = None
        
        # Remove port itself
        if port.scene():
            port.scene().removeItem(port)
    
    def adjust_size_for_expansion(self, expanding_port=None, original_port_pos=None):
        def count_all_visible_items(ports):
            count = 0
            for port in ports:
                count += 1
                if port.expanded and port.subport_widgets:
                    count += count_nested_subports(port.subport_widgets)
            return count
        
        def count_nested_subports(subports):
            count = 0
            for subport in subports:
                count += 1
                if subport.expanded and subport.subport_widgets:
                    count += count_nested_subports(subport.subport_widgets)
            return count
        
        visible_inputs = count_all_visible_items(self.input_ports)
        visible_outputs = count_all_visible_items(self.output_ports)
        
        max_items = max(visible_inputs, visible_outputs)
        required_height = max_items * self.PORT_SPACING + self.HEADER_HEIGHT + 15
        height = max(self.MIN_HEIGHT, required_height)
        width = self.MIN_WIDTH
        
        if expanding_port and original_port_pos:
            self.setRect(0, 0, width, height)
            self._position_ports()
            
            new_port_scene_pos = expanding_port.get_scene_pos()
            delta_y = original_port_pos.y() - new_port_scene_pos.y()
            
            if abs(delta_y) > 0.1:
                self.setPos(self.pos().x(), self.pos().y() + delta_y)
        else:
            self.setRect(0, 0, width, height)
            self._position_ports()
        
        self._update_all_expansion_positions()
        self._update_all_connections()
    
    def _position_ports(self):
        width = self.rect().width()
        
        def calculate_spacing_for_port(port):
            space = self.PORT_SPACING
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    space += calculate_spacing_for_subport(subport)
            return space
        
        def calculate_spacing_for_subport(subport):
            space = PortWidget.SUBPORT_SPACING
            if subport.expanded and subport.subport_widgets:
                for nested in subport.subport_widgets:
                    space += calculate_spacing_for_subport(nested)
            return space
        
        current_y = self.HEADER_HEIGHT
        for i, port in enumerate(self.input_ports):
            current_y += self.PORT_SPACING
            port.setPos(0, current_y)
            if hasattr(port, 'label'):
                port.label.setPos(PortWidget.PORT_RADIUS * 2 + 5, current_y - 8)
            
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    subport_spacing = calculate_spacing_for_subport(subport)
                    current_y += subport_spacing
        
        current_y = self.HEADER_HEIGHT
        for i, port in enumerate(self.output_ports):
            current_y += self.PORT_SPACING
            port.setPos(width, current_y)
            if hasattr(port, 'label'):
                label_width = port.label.boundingRect().width()
                port.label.setPos(width - PortWidget.PORT_RADIUS * 2 - label_width - 5, current_y - 8)
            
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    subport_spacing = calculate_spacing_for_subport(subport)
                    current_y += subport_spacing
    
    def _update_all_expansion_positions(self):
        for port in self.input_ports + self.output_ports:
            self._update_port_expansion_positions(port)
    
    def _update_port_expansion_positions(self, port):
        if port.expanded and port.expansion_widget:
            port.expansion_widget._update_subport_positions()
        for subport in port.subport_widgets:
            self._update_port_expansion_positions(subport)
    
    def _update_all_connections(self):
        for port in self.input_ports + self.output_ports:
            self._update_port_connections(port)
    
    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionHasChanged:
            # Update all connections from current ports
            for port in self.input_ports + self.output_ports:
                self._update_port_connections(port)
            
            # Also update any invalid connections that reference this node
            if self.scene() and self.scene().views():
                view = self.scene().views()[0]
                if hasattr(view, 'connections'):
                    for conn in view.connections:
                        if (conn.output_node == self and not conn.output_valid) or \
                           (conn.input_node == self and not conn.input_valid):
                            conn.update_path()
        
        return super().itemChange(change, value)
    
    def _update_port_connections(self, port):
        try:
            for conn in port.connections[:]:
                conn.update_path()
            for subport in port.subport_widgets[:]:
                self._update_subport_connections(subport)
        except RuntimeError:
            pass
    
    def _update_subport_connections(self, subport):
        try:
            for conn in subport.connections[:]:
                conn.update_path()
            for nested_subport in subport.subport_widgets[:]:
                self._update_subport_connections(nested_subport)
        except RuntimeError:
            pass
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw shadow/glow if selected
        if self.isSelected():
            glow_pen = QPen(QColor(255, 255, 255, 180), 6.0)
            painter.setPen(glow_pen)
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(self.rect())
        
        # Draw the node
        self.setPen(QPen(HOUDINI_NODE_BORDER, 1.5))
        painter.setPen(self.pen())
        painter.setBrush(self.brush())
        painter.drawRect(self.rect())
    
    def get_all_ports(self):
        all_ports = []
        
        def collect_subports(subport):
            all_ports.append(subport)
            for nested_subport in subport.subport_widgets:
                collect_subports(nested_subport)
        
        for port in self.input_ports + self.output_ports:
            all_ports.append(port)
            for subport in port.subport_widgets:
                collect_subports(subport)
        
        return all_ports
    
    def to_dict(self):
        return {
            'type': self.node_type.name,
            'name': self.node_name,
            'x': self.pos().x(),
            'y': self.pos().y(),
            'custom_definition': self.get_type_definition()
        }
    
    def get_type_definition(self):
        """Get the JSON definition of this node's type"""
        def type_to_dict(type_name):
            """Recursively convert a type to dict format, handling custom types"""
            if type_name in self.node_type.custom_port_types:
                custom_type = self.node_type.custom_port_types[type_name]
                subports_list = []
                
                for sp_name, sp_type in custom_type.subports:
                    # Recursively handle subport type
                    if sp_type in self.node_type.custom_port_types:
                        # Nested custom type
                        subports_list.append({
                            'name': sp_name,
                            'type': type_to_dict(sp_type)
                        })
                    else:
                        # Regular type
                        subports_list.append({
                            'name': sp_name,
                            'type': sp_type
                        })
                
                return {
                    'portType': custom_type.name,
                    'subports': subports_list
                }
            else:
                # Not a custom type, just return the name
                return type_name
        
        def port_to_dict(port_name, port_type_name):
            """Convert a port to dict"""
            type_def = type_to_dict(port_type_name)
            return {
                'name': port_name,
                'type': type_def
            }
        
        return {
            'name': self.node_type.name,
            'inputs': [port_to_dict(name, type_) for name, type_ in self.node_type.inputs],
            'outputs': [port_to_dict(name, type_) for name, type_ in self.node_type.outputs]
        }


class NodeEditorScene(QGraphicsScene):
    def __init__(self):
        super().__init__()
        self.temp_connection = None
        self.drag_start_port = None
        self.setBackgroundBrush(QBrush(HOUDINI_BG_DARK))
        self.setSceneRect(-10000, -10000, 20000, 20000)


class NodeEditorView(QGraphicsView):
    def __init__(self, registry):
        super().__init__()
        self.registry = registry
        self.editor_scene = NodeEditorScene()
        self.setScene(self.editor_scene)
        
        self.setRenderHint(QPainter.Antialiasing)
        self.setRenderHint(QPainter.SmoothPixmapTransform)
        self.setDragMode(QGraphicsView.RubberBandDrag)  # Enable rubber band selection
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        self.nodes = []
        self.connections = []
        self.last_mouse_pos = QPointF(0, 0)
        self.is_dragging_connection = False
        self.is_panning = False
        self.pan_start_pos = QPointF()
        self.drag_locked_ports = []
        
        # Structural type matching setting
        self.allow_structural_matching = True
        
        # Signal for selection changes
        self.editor_scene.selectionChanged.connect(self.on_selection_changed)
    
    def set_structural_matching(self, enabled):
        """Enable or disable structural type matching for custom ports"""
        self.allow_structural_matching = enabled
        # Update all existing ports
        for node in self.nodes:
            self._update_node_ports_matching(node)
    
    def _update_node_ports_matching(self, node):
        """Update structural matching setting for all ports in a node"""
        def update_port(port):
            port.allow_structural_matching = self.allow_structural_matching
            for subport in port.subport_widgets:
                update_port(subport)
        
        for port in node.input_ports + node.output_ports:
            update_port(port)
    
    def on_selection_changed(self):
        """Emit signal when selection changes"""
        selected = self.editor_scene.selectedItems()
        selected_nodes = [item for item in selected if isinstance(item, NodeWidget)]
        if hasattr(self, 'selection_changed_callback'):
            self.selection_changed_callback(selected_nodes)
    
    def drawBackground(self, painter, rect):
        super().drawBackground(painter, rect)
        
        grid_size = 20
        left = int(rect.left()) - (int(rect.left()) % grid_size)
        top = int(rect.top()) - (int(rect.top()) % grid_size)
        
        fine_lines = []
        thick_lines = []
        
        x = left
        while x < rect.right():
            if x % 100 == 0:
                thick_lines.append((x, rect.top(), x, rect.bottom()))
            else:
                fine_lines.append((x, rect.top(), x, rect.bottom()))
            x += grid_size
        
        y = top
        while y < rect.bottom():
            if y % 100 == 0:
                thick_lines.append((rect.left(), y, rect.right(), y))
            else:
                fine_lines.append((rect.left(), y, rect.right(), y))
            y += grid_size
        
        painter.setPen(QPen(HOUDINI_GRID_FINE, 1))
        for line in fine_lines:
            painter.drawLine(line[0], line[1], line[2], line[3])
        
        painter.setPen(QPen(HOUDINI_GRID_THICK, 1))
        for line in thick_lines:
            painter.drawLine(line[0], line[1], line[2], line[3])
    
    def _lock_port_hierarchy(self, port):
        self.drag_locked_ports.append(port)
        
        if isinstance(port, SubportWidget):
            current = port.parent_port
            while current:
                self.drag_locked_ports.append(current)
                if hasattr(current, 'parent_port'):
                    current = current.parent_port
                else:
                    break
    
    def _unlock_all_ports(self):
        self.drag_locked_ports.clear()
    
    def _is_port_locked(self, port):
        return port in self.drag_locked_ports
    
    def contextMenuEvent(self, event):
        item = self.itemAt(event.pos())
        if item is None or isinstance(item, QGraphicsTextItem):
            self.show_node_creation_menu(event.pos())
        else:
            super().contextMenuEvent(event)
    
    def mousePressEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        self.last_mouse_pos = self.mapToScene(pos.toPoint())
        
        items = self.items(pos.toPoint())
        
        if event.button() == Qt.LeftButton:
            port_item = None
            for item in items:
                if isinstance(item, (PortWidget, SubportWidget)):
                    port_item = item
                    break
            
            if port_item:
                # Disable rubber band for port dragging
                self.setDragMode(QGraphicsView.NoDrag)
                self._lock_port_hierarchy(port_item)
                self.start_connection(port_item)
                self.is_dragging_connection = True
                event.accept()
                return
            else:
                # Enable rubber band for selection
                self.setDragMode(QGraphicsView.RubberBandDrag)
        
        elif event.button() == Qt.MiddleButton:
            self.setDragMode(QGraphicsView.NoDrag)
            self.is_panning = True
            self.pan_start_pos = pos
            self.setCursor(Qt.ClosedHandCursor)
            event.accept()
            return
        
        super().mousePressEvent(event)
    
    def mouseMoveEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        self.last_mouse_pos = self.mapToScene(pos.toPoint())
        
        if self.is_panning:
            delta = pos - self.pan_start_pos
            self.pan_start_pos = pos
            
            self.horizontalScrollBar().setValue(
                self.horizontalScrollBar().value() - int(delta.x())
            )
            self.verticalScrollBar().setValue(
                self.verticalScrollBar().value() - int(delta.y())
            )
            event.accept()
            return
        
        if self.is_dragging_connection and self.editor_scene.temp_connection:
            try:
                if not self.editor_scene.drag_start_port:
                    self.is_dragging_connection = False
                    self.setDragMode(QGraphicsView.RubberBandDrag)
                    return
                    
                start_pos = self.editor_scene.drag_start_port.get_scene_pos()
                end_pos = self.last_mouse_pos
                
                path = QPainterPath()
                path.moveTo(start_pos)
                
                is_input_drag = self.editor_scene.drag_start_port.is_input
                ctrl_offset = abs(end_pos.x() - start_pos.x()) * 0.5
                
                if is_input_drag:
                    ctrl1 = QPointF(start_pos.x() - ctrl_offset, start_pos.y())
                    ctrl2 = QPointF(end_pos.x() + ctrl_offset, end_pos.y())
                else:
                    ctrl1 = QPointF(start_pos.x() + ctrl_offset, start_pos.y())
                    ctrl2 = QPointF(end_pos.x() - ctrl_offset, end_pos.y())
                
                path.cubicTo(ctrl1, ctrl2, end_pos)
                
                self.editor_scene.temp_connection.setPath(path)
                
                items = self.items(pos.toPoint())
                for item in items:
                    if isinstance(item, (PortWidget, SubportWidget)):
                        if item.is_input and item.is_occupied():
                            break
                        if item.subport_defs and not item.expanded:
                            item.expand()
                        break
                
                event.accept()
                return
            except RuntimeError:
                self.is_dragging_connection = False
                if self.editor_scene.temp_connection:
                    self.editor_scene.removeItem(self.editor_scene.temp_connection)
                    self.editor_scene.temp_connection = None
                self.editor_scene.drag_start_port = None
                self._unlock_all_ports()
                self.setDragMode(QGraphicsView.RubberBandDrag)
                return
        
        super().mouseMoveEvent(event)
    
    def mouseReleaseEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        
        if event.button() == Qt.MiddleButton:
            self.is_panning = False
            self.setDragMode(QGraphicsView.RubberBandDrag)
            self.setCursor(Qt.ArrowCursor)
            event.accept()
            return
        
        if event.button() == Qt.LeftButton and self.is_dragging_connection:
            self.is_dragging_connection = False
            
            if self.editor_scene.temp_connection:
                items = self.items(pos.toPoint())
                
                target_port = None
                for item in items:
                    if isinstance(item, (PortWidget, SubportWidget)):
                        target_port = item
                        break
                
                if target_port and self.editor_scene.drag_start_port:
                    start_port = self.editor_scene.drag_start_port
                    
                    try:
                        _ = start_port.scene()
                        _ = target_port.scene()
                        
                        if start_port.is_connectable_to(target_port):
                            output_port = start_port if not start_port.is_input else target_port
                            input_port = target_port if target_port.is_input else start_port
                            
                            conn = Connection(output_port, input_port, self.editor_scene)
                            self.editor_scene.addItem(conn)
                            self.connections.append(conn)
                    except RuntimeError:
                        pass
                
                self.editor_scene.removeItem(self.editor_scene.temp_connection)
                self.editor_scene.temp_connection = None
                self.editor_scene.drag_start_port = None
            
            self._unlock_all_ports()
            self.setDragMode(QGraphicsView.RubberBandDrag)
            event.accept()
            return
        
        super().mouseReleaseEvent(event)
    
    def start_connection(self, port):
        self.editor_scene.drag_start_port = port
        self.editor_scene.temp_connection = QGraphicsPathItem()
        color = get_type_color(port.type_name)
        self.editor_scene.temp_connection.setPen(QPen(color, 2.5, Qt.DashLine))
        self.editor_scene.addItem(self.editor_scene.temp_connection)
    
    def show_node_creation_menu(self, view_pos):
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 25px 6px 15px;
                border-radius: 3px;
            }}
            QMenu::item:selected {{
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QMenu::separator {{
                height: 1px;
                background: {HOUDINI_NODE_BORDER.name()};
                margin: 4px 0px;
            }}
        """)
        
        scene_pos = self.mapToScene(view_pos)
        
        categories = {}
        for node_type_name in sorted(self.registry.node_types.keys()):
            if '_' in node_type_name:
                category = node_type_name.split('_')[0]
            else:
                category = "Other"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(node_type_name)
        
        for category in sorted(categories.keys()):
            if len(categories) > 1:
                submenu = menu.addMenu(category)
                submenu.setStyleSheet(menu.styleSheet())
            else:
                submenu = menu
            
            for node_type_name in sorted(categories[category]):
                action = submenu.addAction(node_type_name)
                action.triggered.connect(lambda checked=False, name=node_type_name, pos=scene_pos: 
                                       self.add_node(name, pos))
        
        menu.exec(self.mapToGlobal(view_pos))
    
    def show_node_type_menu(self, node, view_pos):
        """Show menu to change node type"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 25px 6px 15px;
                border-radius: 3px;
            }}
            QMenu::item:selected {{
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QMenu::separator {{
                height: 1px;
                background: {HOUDINI_NODE_BORDER.name()};
                margin: 4px 0px;
            }}
        """)
        
        categories = {}
        for node_type_name in sorted(self.registry.node_types.keys()):
            if '_' in node_type_name:
                category = node_type_name.split('_')[0]
            else:
                category = "Other"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(node_type_name)
        
        for category in sorted(categories.keys()):
            if len(categories) > 1:
                submenu = menu.addMenu(category)
                submenu.setStyleSheet(menu.styleSheet())
            else:
                submenu = menu
            
            for node_type_name in sorted(categories[category]):
                action = submenu.addAction(node_type_name)
                action.triggered.connect(lambda checked=False, n=node, name=node_type_name: 
                                       n.change_type(name))
        
        menu.exec(self.mapToGlobal(view_pos))
    
    def add_node(self, node_type_name, pos, custom_definition=None):
        """Add a node to the scene
        
        Args:
            node_type_name: Name of the node type
            pos: Position to place the node
            custom_definition: Optional custom type definition dict
        """
        if custom_definition:
            # Create temporary node type from custom definition
            custom_port_types = {}
            
            # Helper to recursively extract custom port types
            def extract_custom_types(port_type_def):
                """Recursively extract all custom port types from a definition"""
                if isinstance(port_type_def, dict):
                    custom_type_name = port_type_def['portType']
                    subports = []
                    
                    for sp in port_type_def.get('subports', []):
                        sp_name = sp['name']
                        sp_type = sp['type']
                        
                        # Recursively process nested custom types
                        if isinstance(sp_type, dict):
                            extract_custom_types(sp_type)
                            subports.append((sp_name, sp_type['portType']))
                        else:
                            subports.append((sp_name, sp_type))
                    
                    custom_port_types[custom_type_name] = PortType(custom_type_name, subports)
            
            # Parse inputs
            inputs = []
            for inp in custom_definition.get('inputs', []):
                port_name = inp['name']
                port_type = inp['type']
                
                if isinstance(port_type, dict):
                    extract_custom_types(port_type)
                    inputs.append((port_name, port_type['portType']))
                else:
                    inputs.append((port_name, port_type))
            
            # Parse outputs
            outputs = []
            for out in custom_definition.get('outputs', []):
                port_name = out['name']
                port_type = out['type']
                
                if isinstance(port_type, dict):
                    extract_custom_types(port_type)
                    outputs.append((port_name, port_type['portType']))
                else:
                    outputs.append((port_name, port_type))
            
            node_type = NodeType(custom_definition['name'], inputs, outputs, custom_port_types)
        else:
            node_type = self.registry.get_node_type(node_type_name)
            
        if node_type:
            base_name = node_type.name
            counter = 1
            name = base_name
            existing_names = {node.node_name for node in self.nodes}
            while name in existing_names:
                name = f"{base_name}_{counter}"
                counter += 1
            
            node = NodeWidget(node_type, self.registry, name)
            node.setPos(pos)
            self.editor_scene.addItem(node)
            self.nodes.append(node)
            
            # Set structural matching for all ports in new node
            self._update_node_ports_matching(node)
            
            return node
    
    def delete_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                all_ports = item.get_all_ports()
                for port in all_ports:
                    for conn in port.connections[:]:
                        conn.remove()
                        if conn in self.connections:
                            self.connections.remove(conn)
                
                self.nodes.remove(item)
                self.editor_scene.removeItem(item)
            
            elif isinstance(item, Connection):
                item.remove()
                if item in self.connections:
                    self.connections.remove(item)
    
    def rename_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                text, ok = QInputDialog.getText(self, "Rename Node", 
                                               "New name:", QLineEdit.Normal,
                                               item.node_name)
                if ok and text:
                    item.node_name = text
                    item.header.setPlainText(text)
                break
    
    def change_type_selected(self):
        """Change the type of selected node"""
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                view_pos = self.mapFromScene(item.pos())
                self.show_node_type_menu(item, view_pos)
                break
    
    def update_selected_node_type(self, type_definition):
        """Update selected node with custom type definition"""
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                try:
                    item.change_type(type_definition['name'], type_definition)
                except Exception as e:
                    print(f"Error updating node type: {e}")
                break
    
    def frame_all(self):
        if not self.nodes:
            return
        
        min_x = min(node.pos().x() for node in self.nodes)
        max_x = max(node.pos().x() + node.rect().width() for node in self.nodes)
        min_y = min(node.pos().y() for node in self.nodes)
        max_y = max(node.pos().y() + node.rect().height() for node in self.nodes)
        
        padding = 100
        min_x -= padding
        max_x += padding
        min_y -= padding
        max_y += padding
        
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        width = max_x - min_x
        height = max_y - min_y
        
        rect = QRectF(min_x, min_y, width, height)
        self.fitInView(rect, Qt.KeepAspectRatio)
        
        if self.transform().m11() > 2.0:
            self.resetTransform()
            self.scale(1.0, 1.0)
            self.centerOn(center_x, center_y)
    
    def save_to_json(self):
        nodes_data = []
        connections_data = []
        
        for node in self.nodes:
            nodes_data.append(node.to_dict())
        
        for conn in self.connections:
            connections_data.append({
                'output_node': conn.output_node.node_name if conn.output_node else None,
                'output_index_path': conn.output_index_path,
                'input_node': conn.input_node.node_name if conn.input_node else None,
                'input_index_path': conn.input_index_path,
                'output_relative_y': conn.output_relative_y,
                'input_relative_y': conn.input_relative_y
            })
        
        port_types_data = {}
        for type_name, port_type in self.registry.port_types.items():
            port_types_data[type_name] = {
                'subports': [{'name': name, 'type': type_} for name, type_ in port_type.subports]
            }
        
        node_types_data = []
        for node_type in self.registry.node_types.values():
            node_types_data.append({
                'name': node_type.name,
                'inputs': [{'name': name, 'type': type_} for name, type_ in node_type.inputs],
                'outputs': [{'name': name, 'type': type_} for name, type_ in node_type.outputs]
            })
        
        return {
            'port_types': port_types_data,
            'node_types': node_types_data,
            'nodes': nodes_data,
            'connections': connections_data
        }
    
    def load_from_json(self, data):
        if 'port_types' in data or 'node_types' in data:
            self.registry.load_from_json(data)
        
        for node in self.nodes[:]:
            all_ports = node.get_all_ports()
            for port in all_ports:
                for conn in port.connections[:]:
                    if conn in self.connections:
                        self.connections.remove(conn)
                    if conn.scene():
                        self.editor_scene.removeItem(conn)
            self.editor_scene.removeItem(node)
        self.nodes.clear()
        self.connections.clear()
        
        node_map = {}
        for node_data in data.get('nodes', []):
            custom_def = node_data.get('custom_definition')
            node = self.add_node(node_data['type'], 
                               QPointF(node_data['x'], node_data['y']),
                               custom_definition=custom_def)
            if node:
                node.node_name = node_data['name']
                node.header.setPlainText(node_data['name'])
                node_map[node_data['name']] = node
        
        for conn_data in data.get('connections', []):
            output_node = node_map.get(conn_data['output_node'])
            input_node = node_map.get(conn_data['input_node'])
            output_index_path = conn_data.get('output_index_path', [])
            input_index_path = conn_data.get('input_index_path', [])
            
            if output_node or input_node:
                output_port = None
                input_port = None
                
                if output_node and output_index_path:
                    output_port = self._find_port_by_index(output_node, output_index_path, False)
                
                if input_node and input_index_path:
                    input_port = self._find_port_by_index(input_node, input_index_path, True)
                
                conn = Connection(output_port, input_port, self.editor_scene, 
                                output_index_path, input_index_path)
                conn.output_node = output_node
                conn.input_node = input_node
                conn.output_relative_y = conn_data.get('output_relative_y', 0)
                conn.input_relative_y = conn_data.get('input_relative_y', 0)
                conn.output_valid = output_port is not None
                conn.input_valid = input_port is not None
                
                self.editor_scene.addItem(conn)
                self.connections.append(conn)
    
    def _find_port_by_index(self, node, index_path, is_input):
        if not node or not index_path:
            return None
        
        ports = node.input_ports if is_input else node.output_ports
        
        if index_path[0] >= len(ports):
            return None
        
        current_port = ports[index_path[0]]
        
        for idx in index_path[1:]:
            if not current_port.expanded:
                current_port.expand()
            
            if idx >= len(current_port.subport_widgets):
                return None
            
            current_port = current_port.subport_widgets[idx]
        
        return current_port
    
    def expand_selected_connections(self):
        """Expand selected connections and select the newly created ones"""
        selected = self.editor_scene.selectedItems()
        
        new_connections = []
        for item in selected:
            if isinstance(item, Connection):
                expanded = item.expand_connection()
                new_connections.extend(expanded)
                # Add new connections to tracking list
                for conn in expanded:
                    if conn not in self.connections:
                        self.connections.append(conn)
                # Remove old connection from tracking
                if item in self.connections:
                    self.connections.remove(item)
        
        # Select all the newly created connections
        for conn in new_connections:
            conn.setSelected(True)

    def collapse_selected_connections(self):
        """Collapse selected subport connections back to parent connections"""
        selected = self.editor_scene.selectedItems()
        selected_connections = [item for item in selected if isinstance(item, Connection)]
        
        if not selected_connections:
            return
        
        # Group connections by their potential parent ports
        # Key: (output_parent_port, input_parent_port)
        groups = {}
        
        for conn in selected_connections:
            if not conn.output_port or not conn.input_port:
                continue
            
            # Find parent ports
            output_parent = self._get_parent_port(conn.output_port)
            input_parent = self._get_parent_port(conn.input_port)
            
            if not output_parent or not input_parent:
                continue
            
            key = (id(output_parent), id(input_parent), output_parent, input_parent)
            if key not in groups:
                groups[key] = []
            groups[key].append(conn)
        
        # Process each group
        wires_to_flash = []
        new_parent_connections = []
        
        for (_, _, output_parent, input_parent), conns in groups.items():
            result = self._try_collapse_group(output_parent, input_parent, conns)
            if result == 'success':
                # The new parent connection is the last one added
                new_parent_connections.append(result)
            elif result == 'blocked':
                wires_to_flash.extend(conns)
            elif isinstance(result, Connection):
                # Result is the new connection object
                new_parent_connections.append(result)
        
        # Select all newly created parent connections
        for conn in new_parent_connections:
            conn.setSelected(True)
        
        # Flash red wires that couldn't collapse
        if wires_to_flash:
            self._flash_wires_red(wires_to_flash)
    
    def _get_parent_port(self, port):
        """Get the immediate parent port of a subport, or the port itself if it's top-level"""
        if isinstance(port, SubportWidget):
            return port.parent_port
        return None  # Top-level ports don't have parents to collapse to
    
    def _try_collapse_group(self, output_parent, input_parent, selected_conns):
        """Try to collapse a group of connections. Returns Connection object on success, 'blocked' or 'skip' on failure"""
        
        # Check if parent ports already have a direct connection
        if output_parent.connections or input_parent.connections:
            return 'blocked'
        
        # Get all subports of the parent
        all_output_subports = output_parent.subport_widgets if output_parent.expanded else []
        all_input_subports = input_parent.subport_widgets if input_parent.expanded else []
        
        if not all_output_subports or not all_input_subports:
            return 'skip'
        
        # Find which subports are in the selection
        selected_output_subports = set()
        selected_input_subports = set()
        
        for conn in selected_conns:
            selected_output_subports.add(conn.output_port)
            selected_input_subports.add(conn.input_port)
        
        # Check if any sibling connections exist but weren't selected
        for out_subport in all_output_subports:
            if out_subport.connections and out_subport not in selected_output_subports:
                # There's a connection we didn't select
                return 'blocked'
        
        for in_subport in all_input_subports:
            if in_subport.connections and in_subport not in selected_input_subports:
                # There's a connection we didn't select
                return 'blocked'
        
        # All checks passed - perform the collapse
        # Remove all subport connections
        for conn in selected_conns:
            conn.remove()
            if conn in self.connections:
                self.connections.remove(conn)
        
        # Create parent connection
        parent_conn = Connection(output_parent, input_parent, self.editor_scene)
        self.editor_scene.addItem(parent_conn)
        self.connections.append(parent_conn)
        
        # Collapse the expansions (they'll stay expanded if there are other connections)
        output_parent.collapse()
        input_parent.collapse()
        
        return parent_conn
    
    def _flash_wires_red(self, wires):
        """Flash wires red to indicate they can't be collapsed"""
        original_pens = {}
        
        # Store original pens and set to red
        for wire in wires:
            original_pens[wire] = wire.pen()
            wire.setPen(QPen(HOUDINI_ERROR, 3.5))
            wire.update()
        
        # Use QTimer to restore original pens after a delay
        def restore_pens():
            for wire in wires:
                if wire in original_pens and wire.scene():
                    wire.setPen(original_pens[wire])
                    wire.update()
        
        QTimer.singleShot(300, restore_pens)
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete or event.key() == Qt.Key_Backspace:
            self.delete_selected()
        elif event.key() == Qt.Key_F2:
            self.rename_selected()
        elif event.key() == Qt.Key_M:
            self.change_type_selected()
        elif event.key() == Qt.Key_Tab:
            view_pos = self.mapFromScene(self.last_mouse_pos)
            self.show_node_creation_menu(view_pos)
        elif event.key() == Qt.Key_G:
            self.frame_all()
        elif event.key() == Qt.Key_E:
            self.expand_selected_connections()
        elif event.key() == Qt.Key_C:
            self.collapse_selected_connections()
        else:
            super().keyPressEvent(event)
    
    def wheelEvent(self, event):
        zoom_factor = 1.12
        if event.angleDelta().y() > 0:
            self.scale(zoom_factor, zoom_factor)
        else:
            self.scale(1 / zoom_factor, 1 / zoom_factor)


class NodeEditorWidget(QWidget):
    """Main widget for Houdini Python Pane"""
    def __init__(self):
        super().__init__()
        self.registry = NodeTypeRegistry()
        self._load_default_types()
        self._create_ui()
        self.current_selected_node = None
    
    def _load_default_types(self):
        default_config = {
            "port_types": {
                "Float": {"subports": []},
                "Vector3": {
                    "subports": [
                        {"name": "x", "type": "Float"},
                        {"name": "y", "type": "Float"},
                        {"name": "z", "type": "Float"}
                    ]
                },
                "Particle": {
                    "subports": [
                        {"name": "position", "type": "Vector3"},
                        {"name": "velocity", "type": "Vector3"}
                    ]
                }
            },
            "node_types": [
                {
                    "name": "Length",
                    "inputs": [{"name": "vector", "type": "Vector3"}],
                    "outputs": [{"name": "length", "type": "Float"}]
                },
                {
                    "name": "Add",
                    "inputs": [
                        {"name": "a", "type": "Vector3"},
                        {"name": "b", "type": "Vector3"}
                    ],
                    "outputs": [{"name": "result", "type": "Vector3"}]
                }
            ]
        }
        self.registry.load_from_json(default_config)
    
    def _create_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        toolbar_frame = QFrame()
        toolbar_frame.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG.name()};
                border-bottom: 1px solid {HOUDINI_NODE_BORDER.name()};
            }}
            QPushButton {{
                background-color: {HOUDINI_BG_LIGHT.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 4px 12px;
                font-size: 11px;
            }}
            QPushButton:hover {{
                background-color: {HOUDINI_BG_LIGHT.lighter(110).name()};
            }}
            QPushButton:pressed {{
                background-color: {HOUDINI_BG.name()};
            }}
            QLabel {{
                color: {HOUDINI_TEXT_DIM.name()};
                font-size: 10px;
                padding: 0 8px;
            }}
            QCheckBox {{
                color: {HOUDINI_TEXT.name()};
                font-size: 10px;
                padding: 0 8px;
            }}
            QCheckBox::indicator {{
                width: 14px;
                height: 14px;
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QCheckBox::indicator:checked {{
                background-color: {get_type_color('Float').name()};
            }}
        """)
        
        toolbar_layout = QHBoxLayout(toolbar_frame)
        toolbar_layout.setContentsMargins(4, 4, 4, 4)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_graph)
        toolbar_layout.addWidget(save_btn)
        
        load_btn = QPushButton("Load")
        load_btn.clicked.connect(self.load_graph)
        toolbar_layout.addWidget(load_btn)
        
        toolbar_layout.addSpacing(8)
        
        save_to_node_btn = QPushButton("Save to Node")
        save_to_node_btn.clicked.connect(self.save_to_node)
        toolbar_layout.addWidget(save_to_node_btn)
        
        load_from_node_btn = QPushButton("Load from Node")
        load_from_node_btn.clicked.connect(self.load_from_node)
        toolbar_layout.addWidget(load_from_node_btn)
        
        toolbar_layout.addSpacing(8)
        
        load_types_btn = QPushButton("Load Types")
        load_types_btn.clicked.connect(self.load_node_types)
        toolbar_layout.addWidget(load_types_btn)
        
        toolbar_layout.addSpacing(8)
        
        # Structural matching checkbox
        self.structural_matching_cb = QCheckBox("Structural Type Matching")
        self.structural_matching_cb.setChecked(True)
        self.structural_matching_cb.toggled.connect(self.on_structural_matching_changed)
        toolbar_layout.addWidget(self.structural_matching_cb)
        
        toolbar_layout.addStretch()
        
        instructions = QLabel("Drag: select | RMB/Tab: add | M: change type | E: expand | C: collapse | Del: remove | F2: rename | G: frame")
        toolbar_layout.addWidget(instructions)
        
        layout.addWidget(toolbar_frame)
        
        # Create splitter for main content
        splitter = QSplitter(Qt.Horizontal)
        splitter.setStyleSheet(f"""
            QSplitter::handle {{
                background-color: {HOUDINI_NODE_BORDER.name()};
                width: 2px;
            }}
        """)
        
        # Create JSON editor panel
        editor_panel = self._create_editor_panel()
        splitter.addWidget(editor_panel)
        
        # Create node editor
        self.editor = NodeEditorView(self.registry)
        self.editor.selection_changed_callback = self.on_node_selection_changed
        splitter.addWidget(self.editor)
        
        # Set initial sizes (20% editor, 80% view)
        splitter.setSizes([200, 800])
        
        layout.addWidget(splitter)
        
        self.editor.centerOn(0, 0)
    
    def _create_editor_panel(self):
        """Create the JSON editor panel"""
        panel = QFrame()
        panel.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG_DARK.name()};
                border-right: 1px solid {HOUDINI_NODE_BORDER.name()};
            }}
            QTextEdit {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 8px;
                font-family: monospace;
                font-size: 11px;
            }}
            QLabel {{
                color: {HOUDINI_TEXT.name()};
                font-size: 11px;
                font-weight: bold;
                padding: 8px 4px 4px 4px;
            }}
            QPushButton {{
                background-color: {HOUDINI_BG_LIGHT.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 6px 12px;
                font-size: 11px;
            }}
            QPushButton:hover {{
                background-color: {HOUDINI_BG_LIGHT.lighter(110).name()};
            }}
            QPushButton:pressed {{
                background-color: {HOUDINI_BG.name()};
            }}
            QPushButton:disabled {{
                background-color: {HOUDINI_BG_DARK.name()};
                color: {HOUDINI_TEXT_DIM.name()};
            }}
        """)
        
        panel_layout = QVBoxLayout(panel)
        panel_layout.setContentsMargins(8, 8, 8, 8)
        
        # Title
        title = QLabel("Node Type Editor")
        panel_layout.addWidget(title)
        
        # JSON editor
        self.json_editor = QTextEdit()
        self.json_editor.setPlaceholderText("Select a node to edit its type definition...")
        panel_layout.addWidget(self.json_editor)
        
        # Update button
        self.update_btn = QPushButton("Update Node Type")
        self.update_btn.setEnabled(False)
        self.update_btn.clicked.connect(self.update_node_type)
        panel_layout.addWidget(self.update_btn)
        
        # Status label
        self.status_label = QLabel("")
        self.status_label.setStyleSheet(f"color: {HOUDINI_TEXT_DIM.name()}; font-size: 10px; padding: 4px;")
        panel_layout.addWidget(self.status_label)
        
        return panel
    
    def on_node_selection_changed(self, selected_nodes):
        """Handle node selection changes"""
        if selected_nodes:
            self.current_selected_node = selected_nodes[0]
            self.load_node_definition()
            self.update_btn.setEnabled(True)
            self.status_label.setText(f"Editing: {self.current_selected_node.node_name}")
        else:
            self.current_selected_node = None
            self.json_editor.clear()
            self.update_btn.setEnabled(False)
            self.status_label.setText("")
    
    def load_node_definition(self):
        """Load the selected node's type definition into the editor"""
        if not self.current_selected_node:
            return
        
        definition = self.current_selected_node.get_type_definition()
        json_str = json.dumps(definition, indent=2)
        self.json_editor.setText(json_str)
    
    def update_node_type(self):
        """Update the selected node with the edited definition"""
        if not self.current_selected_node:
            return
        
        try:
            json_str = self.json_editor.toPlainText()
            definition = json.loads(json_str)
            
            # Validate basic structure
            if 'name' not in definition:
                self.status_label.setText("Error: Missing 'name' field")
                self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
                return
            
            if 'inputs' not in definition or 'outputs' not in definition:
                self.status_label.setText("Error: Missing 'inputs' or 'outputs'")
                self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
                return
            
            # Update the node
            self.editor.update_selected_node_type(definition)
            
            self.status_label.setText(" Node type updated successfully")
            self.status_label.setStyleSheet(f"color: {get_type_color('Float').name()}; font-size: 10px; padding: 4px;")
            
        except json.JSONDecodeError as e:
            self.status_label.setText(f"JSON Error: {str(e)}")
            self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
        except Exception as e:
            self.status_label.setText(f"Error: {str(e)}")
            self.status_label.setStyleSheet(f"color: {HOUDINI_ERROR.name()}; font-size: 10px; padding: 4px;")
    
    def on_structural_matching_changed(self, checked):
        """Handle structural matching checkbox toggle"""
        self.editor.set_structural_matching(checked)
        status_text = "Structural type matching enabled" if checked else "Strict type name matching enabled"
        self.status_label.setText(status_text)
        self.status_label.setStyleSheet(f"color: {HOUDINI_TEXT_DIM.name()}; font-size: 10px; padding: 4px;")
    
    def save_graph(self):
        filename, _ = QFileDialog.getSaveFileName(self, "Save Graph", "", "JSON Files (*.json)")
        if filename:
            data = self.editor.save_to_json()
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
    
    def load_graph(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Graph", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r') as f:
                data = json.load(f)
            self.editor.load_from_json(data)
    
    def load_node_types(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Node Types", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r') as f:
                data = json.load(f)
            self.registry.load_from_json(data)
    
    def save_to_node(self):
        selected = hou.selectedNodes()
        if not selected:
            hou.ui.displayMessage("Please select a node first", severity=hou.severityType.Warning)
            return
        
        node = selected[0]
        
        if not node.parm('network'):
            parm_template = hou.StringParmTemplate('network', 'Network', 1, 
                                                   string_type=hou.stringParmType.Regular)
            parm_group = node.parmTemplateGroup()
            parm_group.append(parm_template)
            node.setParmTemplateGroup(parm_group)
        
        data = self.editor.save_to_json()
        json_str = json.dumps(data, indent=2)
        node.parm('network').set(json_str)
        
        hou.ui.displayMessage(f"Network saved to node: {node.path()}", severity=hou.severityType.Message)
    
    def load_from_node(self):
        selected = hou.selectedNodes()
        if not selected:
            hou.ui.displayMessage("Please select a node first", severity=hou.severityType.Warning)
            return
        
        node = selected[0]
        
        if not node.parm('network'):
            hou.ui.displayMessage("Selected node has no 'network' parameter", severity=hou.severityType.Warning)
            return
        
        json_str = node.parm('network').eval()
        if not json_str:
            hou.ui.displayMessage("Network parameter is empty", severity=hou.severityType.Warning)
            return
        
        try:
            data = json.loads(json_str)
            self.editor.load_from_json(data)
            hou.ui.displayMessage(f"Network loaded from node: {node.path()}", severity=hou.severityType.Message)
        except json.JSONDecodeError as e:
            hou.ui.displayMessage(f"Failed to parse network data: {e}", severity=hou.severityType.Error)


def createInterface():
    return NodeEditorWidget()]]></script>
    <includeInPaneTabMenu menu_position="0" create_separator="false"/>
    <includeInToolbarMenu menu_position="208" create_separator="false"/>
    <help><![CDATA[]]></help>
  </interface>
</pythonPanelDocument>
