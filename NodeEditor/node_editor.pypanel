<?xml version="1.0" encoding="UTF-8"?>
<pythonPanelDocument>
  <!-- This file contains definitions of Python interfaces and the
 interfaces menu.  It should not be hand-edited when it is being
 used by the application.  Note, that two definitions of the
 same interface or of the interfaces menu are not allowed
 in a single file. -->
  <interface name="Lean Node Editor" label="Lean Node Editor" icon="MISC_python" showNetworkNavigationBar="false" help_url="">
    <script><![CDATA["""
Houdini Node Editor Python Pane with Dynamic Typing
To use: In Houdini, create a new Python Panel and paste this code
"""

import json
import hou
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QGraphicsView, 
                               QGraphicsScene, QGraphicsItem, QGraphicsRectItem,
                               QGraphicsTextItem, QPushButton, QFileDialog, 
                               QGraphicsPathItem, QInputDialog, QLineEdit, QMenu, 
                               QLabel, QFrame)
from PySide6.QtCore import Qt, QRectF, QPointF, QTimer
from PySide6.QtGui import QPen, QBrush, QColor, QPainterPath, QFont, QPainter, QPainterPathStroker, QLinearGradient
from PySide6.QtWidgets import QStyle

# Houdini color scheme
HOUDINI_BG = QColor(58, 58, 58)
HOUDINI_BG_DARK = QColor(38, 38, 38)
HOUDINI_BG_LIGHT = QColor(68, 68, 68)
HOUDINI_NODE_BG = QColor(48, 48, 48)
HOUDINI_NODE_BORDER = QColor(28, 28, 28)
HOUDINI_NODE_SELECTED = QColor(248, 156, 40)
HOUDINI_TEXT = QColor(220, 220, 220)
HOUDINI_TEXT_DIM = QColor(150, 150, 150)
HOUDINI_GRID_FINE = QColor(50, 50, 50)
HOUDINI_GRID_THICK = QColor(60, 60, 60)
HOUDINI_ERROR = QColor(220, 60, 60)


def get_type_color(type_name):
    """Get color for a port type"""
    colors = {
        'Float': QColor(120, 220, 120),
        'Vector3': QColor(100, 180, 255),
        'Particle': QColor(255, 160, 100),
        'Character': QColor(200, 120, 200),
    }
    return colors.get(type_name, QColor(180, 180, 180))


class PortType:
    def __init__(self, name, subports=None):
        self.name = name
        self.subports = subports or []


class NodeType:
    def __init__(self, name, inputs, outputs):
        self.name = name
        self.inputs = inputs
        self.outputs = outputs


class NodeTypeRegistry:
    def __init__(self):
        self.node_types = {}
        self.port_types = {}
    
    def load_from_json(self, json_data):
        data = json.loads(json_data) if isinstance(json_data, str) else json_data
        
        for type_name, type_def in data.get('port_types', {}).items():
            subports = [(sp['name'], sp['type']) for sp in type_def.get('subports', [])]
            self.port_types[type_name] = PortType(type_name, subports)
        
        for node_def in data.get('node_types', []):
            inputs = [(inp['name'], inp['type']) for inp in node_def.get('inputs', [])]
            outputs = [(out['name'], out['type']) for out in node_def.get('outputs', [])]
            self.node_types[node_def['name']] = NodeType(node_def['name'], inputs, outputs)
    
    def get_port_type(self, type_name):
        return self.port_types.get(type_name)
    
    def get_node_type(self, type_name):
        return self.node_types.get(type_name)


class SubportWidget(QGraphicsItem):
    PORT_RADIUS = 5
    SUBPORT_SPACING = 22
    
    def __init__(self, name, type_name, is_input, parent_port, registry):
        super().__init__()
        self.name = name
        self.type_name = type_name
        self.is_input = is_input
        self.parent_port = parent_port
        self.node = parent_port.node
        self.registry = registry
        self.connections = []
        self.hover_active = False
        
        self.subport_widgets = []
        self.expanded = False
        self.expansion_widget = None
        
        port_type = registry.get_port_type(type_name)
        self.subport_defs = []
        if port_type and port_type.subports:
            self.subport_defs = port_type.subports
        
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
    
    def boundingRect(self):
        return QRectF(-self.PORT_RADIUS, -self.PORT_RADIUS, 
                     self.PORT_RADIUS * 2, self.PORT_RADIUS * 2)
    
    def shape(self):
        path = QPainterPath()
        radius = self.PORT_RADIUS + 5
        path.addEllipse(QPointF(0, 0), radius, radius)
        return path
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        color = get_type_color(self.type_name)
        
        if self.has_connection():
            painter.setBrush(QBrush(color))
        else:
            painter.setBrush(QBrush(color.darker(180)))
        
        border_width = 2.5 if self.hover_active else 1.5
        painter.setPen(QPen(color.darker(120), border_width))
        painter.drawEllipse(self.boundingRect())
    
    def get_full_path(self):
        return f"{self.parent_port.get_full_path()}.{self.name}"
    
    def get_index_path(self):
        """Get the index path [port_idx, subport_idx, ...]"""
        path = []
        current = self
        while hasattr(current, 'parent_port') and current.parent_port:
            parent = current.parent_port
            if hasattr(parent, 'subport_widgets'):
                idx = parent.subport_widgets.index(current) if current in parent.subport_widgets else -1
                path.insert(0, idx)
            current = parent
        
        if hasattr(current, 'node'):
            ports = current.node.input_ports if current.is_input else current.node.output_ports
            if current in ports:
                path.insert(0, ports.index(current))
        
        return path
    
    def has_connection(self):
        if self.connections:
            return True
        for subport in self.subport_widgets:
            if subport.has_connection():
                return True
        return False
    
    def is_connectable_to(self, other_port):
        if self.is_input == other_port.is_input:
            return False
        if self.node == other_port.node:
            return False
        if self.type_name != other_port.type_name:
            return False
        input_port = self if self.is_input else other_port
        if input_port.is_occupied():
            return False
        return True
    
    def is_occupied(self):
        if self.connections:
            return True
        current = self.parent_port
        while current:
            if current.connections:
                return True
            current = current.parent_port if hasattr(current, 'parent_port') else None
        return self._has_connected_descendant()
    
    def _has_connected_descendant(self):
        for subport in self.subport_widgets:
            if subport.connections or subport._has_connected_descendant():
                return True
        return False
    
    def get_scene_pos(self):
        return self.scenePos()
    
    def expand(self):
        if not self.subport_defs or self.expanded:
            return
        
        self.expanded = True
        original_scene_pos = self.get_scene_pos()
        
        self.subport_widgets = []
        for subport_name, subport_type in self.subport_defs:
            subport = SubportWidget(subport_name, subport_type, self.is_input, self, self.registry)
            self.subport_widgets.append(subport)
        
        self.expansion_widget = SubportExpansion(self, self.subport_widgets, self.is_input)
        self.expansion_widget.setParentItem(self.node)
        
        node_pos = self.node.mapFromItem(self, 0, 0)
        if self.is_input:
            self.expansion_widget.setPos(node_pos.x() - SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        else:
            self.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        
        self._update_parent_expansions()
        
        if self.node:
            self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def _update_parent_expansions(self):
        current = self.parent_port
        while current:
            if hasattr(current, 'expansion_widget') and current.expansion_widget:
                current.expansion_widget._update_subport_positions()
            if hasattr(current, 'parent_port'):
                current = current.parent_port
            else:
                break
    
    def collapse(self):
        if not self.expanded:
            return
        
        if self.node and self.node.scene():
            view = self.node.scene().views()[0] if self.node.scene().views() else None
            if view and hasattr(view, '_is_port_locked') and view._is_port_locked(self):
                return
        
        has_connections = any(subport.has_connection() for subport in self.subport_widgets)
        
        if not has_connections:
            original_scene_pos = self.get_scene_pos()
            self.expanded = False
            
            for subport in self.subport_widgets[:]:
                if subport.expanded:
                    subport.collapse()
            
            if self.expansion_widget:
                scene = self.scene()
                if scene and self.expansion_widget.scene() == scene:
                    scene.removeItem(self.expansion_widget)
                self.expansion_widget = None
            
            self.subport_widgets = []
            self._update_parent_expansions()
            
            if self.node:
                self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def hoverEnterEvent(self, event):
        self.hover_active = True
        self.update()
        if self.is_input and self.is_occupied():
            super().hoverEnterEvent(event)
            return
        if self.subport_defs and not self.expanded:
            self.expand()
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        self.hover_active = False
        self.update()
        QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.hover_active:
            return
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return
        if self._is_any_expansion_hovered():
            return
        self.collapse()
    
    def _is_any_expansion_hovered(self):
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return True
        for subport in self.subport_widgets:
            if subport.hover_active:
                return True
            if subport._is_any_expansion_hovered():
                return True
        return False


class PortWidget(QGraphicsItem):
    PORT_RADIUS = 6
    SUBPORT_SPACING = 22
    
    def __init__(self, name, type_name, registry, is_input, parent_port=None, node=None):
        super().__init__()
        self.name = name
        self.type_name = type_name
        self.registry = registry
        self.is_input = is_input
        self.parent_port = parent_port
        self.node = node
        self.subport_widgets = []
        self.expanded = False
        self.expansion_widget = None
        self.connections = []
        self.hover_active = False
        
        port_type = registry.get_port_type(type_name)
        self.subport_defs = []
        if port_type and port_type.subports:
            self.subport_defs = port_type.subports
        
        self.setAcceptHoverEvents(True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, False)
        self.setAcceptedMouseButtons(Qt.NoButton)
    
    def boundingRect(self):
        return QRectF(-self.PORT_RADIUS, -self.PORT_RADIUS, 
                     self.PORT_RADIUS * 2, self.PORT_RADIUS * 2)
    
    def shape(self):
        path = QPainterPath()
        radius = self.PORT_RADIUS + 5
        path.addEllipse(QPointF(0, 0), radius, radius)
        return path
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        color = get_type_color(self.type_name)
        
        if self.has_connection():
            painter.setBrush(QBrush(color))
        else:
            painter.setBrush(QBrush(color.darker(180)))
        
        border_width = 2.5 if self.hover_active else 1.5
        painter.setPen(QPen(color.darker(120), border_width))
        painter.drawEllipse(self.boundingRect())
    
    def get_full_path(self):
        if self.parent_port:
            return f"{self.parent_port.get_full_path()}.{self.name}"
        return self.name
    
    def get_index_path(self):
        """Get the index path [port_idx, subport_idx, ...]"""
        ports = self.node.input_ports if self.is_input else self.node.output_ports
        if self in ports:
            return [ports.index(self)]
        return []
    
    def has_connection(self):
        if self.connections:
            return True
        for subport in self.subport_widgets:
            if subport.has_connection():
                return True
        return False
    
    def is_connectable_to(self, other_port):
        if self.is_input == other_port.is_input:
            return False
        if self.node == other_port.node:
            return False
        if self.type_name != other_port.type_name:
            return False
        input_port = self if self.is_input else other_port
        if input_port.is_occupied():
            return False
        return True
    
    def is_occupied(self):
        if self.connections:
            return True
        current = self.parent_port
        while current:
            if current.connections:
                return True
            current = current.parent_port
        return self._has_connected_descendant()
    
    def _has_connected_descendant(self):
        for subport in self.subport_widgets:
            if subport.connections or subport._has_connected_descendant():
                return True
        return False
    
    def get_scene_pos(self):
        return self.scenePos()
    
    def expand(self):
        if not self.subport_defs or self.expanded:
            return
        
        self.expanded = True
        original_scene_pos = self.get_scene_pos()
        
        self.subport_widgets = []
        for subport_name, subport_type in self.subport_defs:
            subport = SubportWidget(subport_name, subport_type, self.is_input, self, self.registry)
            self.subport_widgets.append(subport)
        
        self.expansion_widget = SubportExpansion(self, self.subport_widgets, self.is_input)
        self.expansion_widget.setParentItem(self.node)
        
        node_pos = self.node.mapFromItem(self, 0, 0)
        if self.is_input:
            self.expansion_widget.setPos(node_pos.x() - SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        else:
            self.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH, 
                                        node_pos.y() + self.PORT_RADIUS)
        
        self._update_parent_expansions()
        
        if self.node:
            self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def _update_parent_expansions(self):
        current = self.parent_port
        while current:
            if hasattr(current, 'expansion_widget') and current.expansion_widget:
                current.expansion_widget._update_subport_positions()
            if hasattr(current, 'parent_port'):
                current = current.parent_port
            else:
                break
    
    def collapse(self):
        if not self.expanded:
            return
        
        if self.node and self.node.scene():
            view = self.node.scene().views()[0] if self.node.scene().views() else None
            if view and hasattr(view, '_is_port_locked') and view._is_port_locked(self):
                return
        
        has_connections = any(subport.has_connection() for subport in self.subport_widgets)
        
        if not has_connections:
            original_scene_pos = self.get_scene_pos()
            self.expanded = False
            
            for subport in self.subport_widgets[:]:
                if subport.expanded:
                    subport.collapse()
            
            if self.expansion_widget:
                scene = self.scene()
                if scene and self.expansion_widget.scene() == scene:
                    scene.removeItem(self.expansion_widget)
                self.expansion_widget = None
            
            self.subport_widgets = []
            
            if self.node:
                self.node.adjust_size_for_expansion(self, original_scene_pos)
    
    def hoverEnterEvent(self, event):
        self.hover_active = True
        self.update()
        if self.is_input and self.is_occupied():
            super().hoverEnterEvent(event)
            return
        if self.subport_defs and not self.expanded:
            self.expand()
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        self.hover_active = False
        self.update()
        QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.hover_active:
            return
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return
        if self._is_any_expansion_hovered():
            return
        self.collapse()
    
    def _is_any_expansion_hovered(self):
        if self.expansion_widget and self.expansion_widget.isUnderMouse():
            return True
        for subport in self.subport_widgets:
            if subport.hover_active:
                return True
            if subport._is_any_expansion_hovered():
                return True
        return False


class SubportExpansion(QGraphicsRectItem):
    WIDTH = 12
    HOVER_MARGIN = 30
    
    def __init__(self, parent_port, subports, is_input):
        super().__init__()
        self.parent_port = parent_port
        self.subports = subports
        self.is_input = is_input
        self.labels = []
        
        self.setAcceptHoverEvents(True)
        
        height = len(subports) * PortWidget.SUBPORT_SPACING
        
        # Position rectangle based on port direction
        if is_input:
            # For input: rectangle extends to the right (away from node)
            self.setRect(0, 0, self.WIDTH, height)
        else:
            # For output: rectangle extends to the left (toward node, away from port)
            self.setRect(-self.WIDTH, 0, self.WIDTH, height)
        
        self.setBrush(QBrush(HOUDINI_BG_LIGHT))
        self.setPen(QPen(HOUDINI_NODE_BORDER, 1))
        
        self._update_subport_positions()
    
    def _update_subport_positions(self):
        current_y = PortWidget.SUBPORT_SPACING // 2
        
        for i, subport in enumerate(self.subports):
            if subport.parentItem() != self:
                subport.setParentItem(self)
            
            if self.is_input:
                # For input: place subports at the right edge of expansion (away from main port)
                subport.setPos(self.WIDTH, current_y)
            else:
                # For output: place subports at the left edge of expansion (away from main port)
                subport.setPos(0, current_y)
            
            # Create or update label
            if i < len(self.labels):
                label = self.labels[i]
            else:
                label = QGraphicsTextItem(subport.name, self)
                label.setDefaultTextColor(HOUDINI_TEXT)
                font = QFont("Arial", 9)
                label.setFont(font)
                self.labels.append(label)
            
            # Position labels consistently for both input and output
            node = subport.node
            if self.is_input:
                # For input: label to the right of the subport
                label.setPos(self.WIDTH + PortWidget.PORT_RADIUS * 2 + 5, current_y - 8)
            else:
                # For output: label to the left of the subport
                label_width = label.boundingRect().width()
                label.setPos(-PortWidget.PORT_RADIUS * 2 - label_width - 5, current_y - 8)
            
            # Update nested expansion positions
            if subport.expanded and subport.expansion_widget:
                node_pos = subport.node.mapFromItem(subport, 0, 0)
                if self.is_input:
                    # Input subport expansion goes further right
                    subport.expansion_widget.setPos(node_pos.x() + SubportExpansion.WIDTH,
                                                   node_pos.y() + subport.PORT_RADIUS)
                else:
                    # Output subport expansion goes further left
                    subport.expansion_widget.setPos(node_pos.x() - SubportExpansion.WIDTH,
                                                   node_pos.y() + subport.PORT_RADIUS)
            
            current_y += PortWidget.SUBPORT_SPACING
            if subport.expanded and subport.subport_widgets:
                current_y += self._calculate_subport_expansion_height(subport)
        
        new_height = current_y - PortWidget.SUBPORT_SPACING // 2
        
        # Update rectangle size based on direction
        if self.is_input:
            self.setRect(0, 0, self.WIDTH, new_height)
        else:
            self.setRect(-self.WIDTH, 0, self.WIDTH, new_height)
    
    def _calculate_subport_expansion_height(self, subport):
        if not subport.expanded or not subport.subport_widgets:
            return 0
        
        height = 0
        for nested in subport.subport_widgets:
            height += PortWidget.SUBPORT_SPACING
            if nested.expanded and nested.subport_widgets:
                height += self._calculate_subport_expansion_height(nested)
        return height
    
    def shape(self):
        path = QPainterPath()
        rect = self.rect()
        if self.is_input:
            # Input: expand hover area to the right
            expanded = QRectF(rect.x() - 5, 
                            rect.y() - 5, 
                            rect.width() + self.HOVER_MARGIN + 100,
                            rect.height() + 10)
        else:
            # Output: expand hover area to the left
            expanded = QRectF(rect.x() - self.HOVER_MARGIN - 100,
                            rect.y() - 5, 
                            rect.width() + self.HOVER_MARGIN + 100, 
                            rect.height() + 10)
        path.addRect(expanded)
        return path
    
    def hoverLeaveEvent(self, event):
        if not self.isUnderMouse():
            QTimer.singleShot(500, self.try_collapse)
        super().hoverLeaveEvent(event)
    
    def try_collapse(self):
        if self.isUnderMouse():
            return
        if self.parent_port.hover_active:
            return
        if self.parent_port._is_any_expansion_hovered():
            return
        self.parent_port.collapse()
        

class Connection(QGraphicsPathItem):
    def __init__(self, output_port, input_port, scene, output_index_path=None, input_index_path=None):
        super().__init__()
        self.output_port = output_port
        self.input_port = input_port
        self.output_node = output_port.node if output_port else None
        self.input_node = input_port.node if input_port else None
        
        # Store index paths for reconnection
        self.output_index_path = output_index_path or (output_port.get_index_path() if output_port else [])
        self.input_index_path = input_index_path or (input_port.get_index_path() if input_port else [])
        
        # Store relative positions for invalid connections
        if self.output_node and output_port:
            self.output_relative_y = output_port.get_scene_pos().y() - self.output_node.pos().y()
        else:
            self.output_relative_y = 0
            
        if self.input_node and input_port:
            self.input_relative_y = input_port.get_scene_pos().y() - self.input_node.pos().y()
        else:
            self.input_relative_y = 0
        
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        # Don't allow moving wires - they're determined by node positions
        self.setFlag(QGraphicsItem.ItemIsMovable, False)
        
        # Determine connection validity
        self.output_valid = output_port is not None
        self.input_valid = input_port is not None
        
        color = get_type_color(output_port.type_name) if output_port else HOUDINI_ERROR
        self.normal_pen = QPen(color, 2.5)
        self.selected_pen = QPen(HOUDINI_NODE_SELECTED, 3.5)
        self.invalid_pen = QPen(HOUDINI_ERROR, 2.5)
        
        # Shadow pen for selection
        self.shadow_pen = QPen(QColor(255, 255, 255, 180), 6.0)
        
        if output_port:
            output_port.connections.append(self)
        if input_port:
            input_port.connections.append(self)
        
        if output_port and isinstance(output_port, SubportWidget):
            self._expand_hierarchy(output_port)
        if input_port and isinstance(input_port, SubportWidget):
            self._expand_hierarchy(input_port)
        
        self.update_path()
    
    def is_valid(self):
        """Check if connection is valid (both ends exist and types match)"""
        if not (self.output_valid and self.input_valid):
            return False
        # Check type compatibility
        if self.output_port and self.input_port:
            return self.output_port.type_name == self.input_port.type_name
        return False
    
    def has_type_mismatch(self):
        """Check if both ends exist but types don't match"""
        return (self.output_valid and self.input_valid and 
                self.output_port.type_name != self.input_port.type_name)
    
    def boundingRect(self):
        """Override to prevent default selection border"""
        # Add a bit of padding for the shadow
        if self.isSelected():
            return self.path().boundingRect().adjusted(-4, -4, 4, 4)
        return self.path().boundingRect()
    
    def shape(self):
        stroker = QPainterPathStroker()
        stroker.setWidth(12)
        stroker.setCapStyle(Qt.RoundCap)
        return stroker.createStroke(self.path())
    
    def _expand_hierarchy(self, port):
        if isinstance(port, SubportWidget):
            try:
                current = port.parent_port
                while current:
                    _ = current.scene()
                    if not current.expanded:
                        current.expand()
                    current = current.parent_port if hasattr(current, 'parent_port') else None
            except RuntimeError:
                pass
    
    def update_path(self):
        try:
            # Get positions
            if self.output_port:
                start = self.output_port.get_scene_pos()
            elif self.output_node:
                # Use relative position for invalid output
                start = QPointF(self.output_node.pos().x() + self.output_node.rect().width(),
                              self.output_node.pos().y() + self.output_relative_y)
            else:
                return
            
            if self.input_port:
                end = self.input_port.get_scene_pos()
            elif self.input_node:
                # Use relative position for invalid input
                end = QPointF(self.input_node.pos().x(),
                            self.input_node.pos().y() + self.input_relative_y)
            else:
                return
            
            path = QPainterPath()
            path.moveTo(start)
            
            ctrl_offset = abs(end.x() - start.x()) * 0.5
            ctrl1 = QPointF(start.x() + ctrl_offset, start.y())
            ctrl2 = QPointF(end.x() - ctrl_offset, end.y())
            path.cubicTo(ctrl1, ctrl2, end)
            
            self.setPath(path)
        except RuntimeError:
            if self.scene():
                self.scene().removeItem(self)
    
    def remove(self):
        try:
            if self.output_port and self in self.output_port.connections:
                self.output_port.connections.remove(self)
        except (RuntimeError, AttributeError):
            pass
            
        try:
            if self.input_port and self in self.input_port.connections:
                self.input_port.connections.remove(self)
        except (RuntimeError, AttributeError):
            pass
        
        def try_collapse_hierarchy(port):
            try:
                if isinstance(port, SubportWidget):
                    port.collapse()
                    if hasattr(port, 'parent_port') and port.parent_port:
                        try_collapse_hierarchy(port.parent_port)
                elif isinstance(port, PortWidget):
                    port.collapse()
            except RuntimeError:
                pass
        
        if self.output_port:
            try:
                try_collapse_hierarchy(self.output_port)
            except (RuntimeError, AttributeError):
                pass
            
        if self.input_port:
            try:
                try_collapse_hierarchy(self.input_port)
            except (RuntimeError, AttributeError):
                pass
        
        if self.scene():
            self.scene().removeItem(self)
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw shadow if selected
        if self.isSelected():
            painter.setPen(self.shadow_pen)
            painter.drawPath(self.path())
        
        # Draw the main wire
        if self.has_type_mismatch():
            # Type mismatch - gradient from output color to input color
            output_color = get_type_color(self.output_port.type_name)
            input_color = get_type_color(self.input_port.type_name)
            gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
            gradient.setColorAt(0, output_color)
            gradient.setColorAt(1, input_color)
            pen = QPen(QBrush(gradient), 2.5)
        elif not self.is_valid():
            # Invalid connection (missing port)
            if self.output_valid and not self.input_valid:
                # Valid output, invalid input - gradient from normal to red
                gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
                gradient.setColorAt(0, self.normal_pen.color())
                gradient.setColorAt(1, HOUDINI_ERROR)
                pen = QPen(QBrush(gradient), 2.5)
            elif not self.output_valid and self.input_valid:
                # Invalid output, valid input - gradient from red to normal
                gradient = QLinearGradient(self.path().pointAtPercent(0), self.path().pointAtPercent(1))
                gradient.setColorAt(0, HOUDINI_ERROR)
                gradient.setColorAt(1, self.normal_pen.color())
                pen = QPen(QBrush(gradient), 2.5)
            else:
                # Both invalid
                pen = self.invalid_pen
        else:
            pen = self.normal_pen
        
        painter.setPen(pen)
        painter.drawPath(self.path())
    
    def expand_connection(self):
        """Expand this connection into subport connections"""
        if not self.output_port or not self.input_port:
            return []
        
        if not self.output_port.subport_defs or not self.input_port.subport_defs:
            return []
        
        if not self.output_port.expanded:
            self.output_port.expand()
        if not self.input_port.expanded:
            self.input_port.expand()
        
        output_subports = {sp.name: sp for sp in self.output_port.subport_widgets}
        input_subports = {sp.name: sp for sp in self.input_port.subport_widgets}
        
        new_connections = []
        for name in output_subports:
            if name in input_subports:
                out_sp = output_subports[name]
                in_sp = input_subports[name]
                if out_sp.type_name == in_sp.type_name:
                    conn = Connection(out_sp, in_sp, self.scene())
                    if self.scene():
                        self.scene().addItem(conn)
                    new_connections.append(conn)
        
        self.remove()
        return new_connections
    
    def reconnect(self):
        """Try to reconnect to ports based on stored index paths"""
        # Remove from old port lists if they exist
        if self.output_port and self in self.output_port.connections:
            self.output_port.connections.remove(self)
        if self.input_port and self in self.input_port.connections:
            self.input_port.connections.remove(self)
        
        # Try to find new ports
        self.output_port = self._find_port_by_index(self.output_node, self.output_index_path, False)
        self.input_port = self._find_port_by_index(self.input_node, self.input_index_path, True)
        
        # Update validity state
        self.output_valid = self.output_port is not None
        self.input_valid = self.input_port is not None
        
        # Update relative positions for current node state
        if self.output_node and self.output_port:
            self.output_relative_y = self.output_port.get_scene_pos().y() - self.output_node.pos().y()
        elif self.output_node:
            # Keep the old relative position for invalid connections
            pass
            
        if self.input_node and self.input_port:
            self.input_relative_y = self.input_port.get_scene_pos().y() - self.input_node.pos().y()
        elif self.input_node:
            # Keep the old relative position for invalid connections
            pass
        
        # Update pen color based on new port type
        if self.output_port:
            color = get_type_color(self.output_port.type_name)
            self.normal_pen = QPen(color, 2.5)
        elif self.input_port:
            # If no output port, use input port color
            color = get_type_color(self.input_port.type_name)
            self.normal_pen = QPen(color, 2.5)
        
        # Add to new port connection lists
        if self.output_port and self not in self.output_port.connections:
            self.output_port.connections.append(self)
        if self.input_port and self not in self.input_port.connections:
            self.input_port.connections.append(self)
        
        # Expand hierarchies if needed
        if self.output_port and isinstance(self.output_port, SubportWidget):
            self._expand_hierarchy(self.output_port)
        if self.input_port and isinstance(self.input_port, SubportWidget):
            self._expand_hierarchy(self.input_port)
        
        # Update the visual path
        self.update_path()
        self.update()
    
    def _find_port_by_index(self, node, index_path, is_input):
        """Find port by index path [port_idx, subport_idx, ...]"""
        if not node or not index_path:
            return None
        
        ports = node.input_ports if is_input else node.output_ports
        
        if index_path[0] >= len(ports):
            return None
        
        current_port = ports[index_path[0]]
        
        for idx in index_path[1:]:
            if not current_port.expanded:
                current_port.expand()
            
            if idx >= len(current_port.subport_widgets):
                return None
            
            current_port = current_port.subport_widgets[idx]
        
        return current_port


class NodeWidget(QGraphicsRectItem):
    MIN_WIDTH = 180
    MIN_HEIGHT = 60
    PORT_SPACING = 28
    HEADER_HEIGHT = 32
    
    def __init__(self, node_type, registry, name=None):
        super().__init__()
        self.node_type = node_type
        self.registry = registry
        self.node_name = name or node_type.name
        self.input_ports = []
        self.output_ports = []
        
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        
        self.setBrush(QBrush(HOUDINI_NODE_BG))
        self.setPen(QPen(HOUDINI_NODE_BORDER, 2))
        
        self.header = QGraphicsTextItem(self.node_name, self)
        self.header.setDefaultTextColor(HOUDINI_TEXT)
        font = QFont("Arial", 10, QFont.Bold)
        self.header.setFont(font)
        self.header.setPos(8, 6)
        
        self._create_ports()
        self.adjust_size_for_expansion()
    
    def _create_ports(self):
        for i, (port_name, port_type) in enumerate(self.node_type.inputs):
            port = PortWidget(port_name, port_type, self.registry, True, None, self)
            port.setParentItem(self)
            self.input_ports.append(port)
            
            label = QGraphicsTextItem(port_name, self)
            label.setDefaultTextColor(HOUDINI_TEXT)
            font = QFont("Arial", 9)
            label.setFont(font)
            port.label = label
        
        for i, (port_name, port_type) in enumerate(self.node_type.outputs):
            port = PortWidget(port_name, port_type, self.registry, False, None, self)
            port.setParentItem(self)
            self.output_ports.append(port)
            
            label = QGraphicsTextItem(port_name, self)
            label.setDefaultTextColor(HOUDINI_TEXT)
            font = QFont("Arial", 9)
            label.setFont(font)
            port.label = label
    
    def change_type(self, new_type_name):
        """Change this node to a different type, preserving connections where possible"""
        new_type = self.registry.get_node_type(new_type_name)
        if not new_type:
            return
        
        # Get the view to access all connections
        view = None
        if self.scene() and self.scene().views():
            view = self.scene().views()[0]
        
        # Collect all connections that reference this node
        all_connections = []
        if view:
            for conn in view.connections:
                if conn.output_node == self or conn.input_node == self:
                    all_connections.append(conn)
        
        # Remove connections from old ports' lists
        for port in self.input_ports + self.output_ports:
            self._remove_port_connections(port)
        
        # Clear old ports completely
        for port in self.input_ports + self.output_ports:
            self._clear_port_completely(port)
        self.input_ports.clear()
        self.output_ports.clear()
        
        # Update type and name
        self.node_type = new_type
        self.node_name = new_type.name
        self.header.setPlainText(self.node_name)
        
        # Create new ports
        self._create_ports()
        self.adjust_size_for_expansion()
        
        # Try to reconnect all connections
        for conn in all_connections:
            conn.reconnect()
    
    def _remove_port_connections(self, port):
        """Remove connections from port's list but don't delete from scene"""
        for subport in port.subport_widgets[:]:
            self._remove_port_connections(subport)
        port.connections.clear()
    
    def _clear_port_completely(self, port):
        """Completely remove a port and all its visual elements"""
        # Clear subports first
        for subport in port.subport_widgets[:]:
            self._clear_port_completely(subport)
        
        # Remove expansion widget
        if hasattr(port, 'expansion_widget') and port.expansion_widget:
            if port.expansion_widget.scene():
                port.expansion_widget.scene().removeItem(port.expansion_widget)
            port.expansion_widget = None
        
        # Remove label
        if hasattr(port, 'label') and port.label:
            if port.label.scene():
                port.label.scene().removeItem(port.label)
            port.label = None
        
        # Remove port itself
        if port.scene():
            port.scene().removeItem(port)
    
    def adjust_size_for_expansion(self, expanding_port=None, original_port_pos=None):
        def count_all_visible_items(ports):
            count = 0
            for port in ports:
                count += 1
                if port.expanded and port.subport_widgets:
                    count += count_nested_subports(port.subport_widgets)
            return count
        
        def count_nested_subports(subports):
            count = 0
            for subport in subports:
                count += 1
                if subport.expanded and subport.subport_widgets:
                    count += count_nested_subports(subport.subport_widgets)
            return count
        
        visible_inputs = count_all_visible_items(self.input_ports)
        visible_outputs = count_all_visible_items(self.output_ports)
        
        max_items = max(visible_inputs, visible_outputs)
        required_height = max_items * self.PORT_SPACING + self.HEADER_HEIGHT + 15
        height = max(self.MIN_HEIGHT, required_height)
        width = self.MIN_WIDTH
        
        if expanding_port and original_port_pos:
            self.setRect(0, 0, width, height)
            self._position_ports()
            
            new_port_scene_pos = expanding_port.get_scene_pos()
            delta_y = original_port_pos.y() - new_port_scene_pos.y()
            
            if abs(delta_y) > 0.1:
                self.setPos(self.pos().x(), self.pos().y() + delta_y)
        else:
            self.setRect(0, 0, width, height)
            self._position_ports()
        
        self._update_all_expansion_positions()
        self._update_all_connections()
    
    def _position_ports(self):
        width = self.rect().width()
        
        def calculate_spacing_for_port(port):
            space = self.PORT_SPACING
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    space += calculate_spacing_for_subport(subport)
            return space
        
        def calculate_spacing_for_subport(subport):
            space = PortWidget.SUBPORT_SPACING
            if subport.expanded and subport.subport_widgets:
                for nested in subport.subport_widgets:
                    space += calculate_spacing_for_subport(nested)
            return space
        
        current_y = self.HEADER_HEIGHT
        for i, port in enumerate(self.input_ports):
            current_y += self.PORT_SPACING
            port.setPos(0, current_y)
            if hasattr(port, 'label'):
                port.label.setPos(PortWidget.PORT_RADIUS * 2 + 5, current_y - 8)
            
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    subport_spacing = calculate_spacing_for_subport(subport)
                    current_y += subport_spacing
        
        current_y = self.HEADER_HEIGHT
        for i, port in enumerate(self.output_ports):
            current_y += self.PORT_SPACING
            port.setPos(width, current_y)
            if hasattr(port, 'label'):
                label_width = port.label.boundingRect().width()
                port.label.setPos(width - PortWidget.PORT_RADIUS * 2 - label_width - 5, current_y - 8)
            
            if port.expanded and port.subport_widgets:
                for subport in port.subport_widgets:
                    subport_spacing = calculate_spacing_for_subport(subport)
                    current_y += subport_spacing
    
    def _update_all_expansion_positions(self):
        for port in self.input_ports + self.output_ports:
            self._update_port_expansion_positions(port)
    
    def _update_port_expansion_positions(self, port):
        if port.expanded and port.expansion_widget:
            port.expansion_widget._update_subport_positions()
        for subport in port.subport_widgets:
            self._update_port_expansion_positions(subport)
    
    def _update_all_connections(self):
        for port in self.input_ports + self.output_ports:
            self._update_port_connections(port)
    
    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionHasChanged:
            # Update all connections from current ports
            for port in self.input_ports + self.output_ports:
                self._update_port_connections(port)
            
            # Also update any invalid connections that reference this node
            if self.scene() and self.scene().views():
                view = self.scene().views()[0]
                if hasattr(view, 'connections'):
                    for conn in view.connections:
                        if (conn.output_node == self and not conn.output_valid) or \
                           (conn.input_node == self and not conn.input_valid):
                            conn.update_path()
        
        return super().itemChange(change, value)
    
    def _update_port_connections(self, port):
        try:
            for conn in port.connections[:]:
                conn.update_path()
            for subport in port.subport_widgets[:]:
                self._update_subport_connections(subport)
        except RuntimeError:
            pass
    
    def _update_subport_connections(self, subport):
        try:
            for conn in subport.connections[:]:
                conn.update_path()
            for nested_subport in subport.subport_widgets[:]:
                self._update_subport_connections(nested_subport)
        except RuntimeError:
            pass
    
    def paint(self, painter, option, widget):
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw shadow/glow if selected
        if self.isSelected():
            glow_pen = QPen(QColor(255, 255, 255, 180), 6.0)
            painter.setPen(glow_pen)
            painter.setBrush(Qt.NoBrush)
            painter.drawRect(self.rect())
        
        # Draw the node
        self.setPen(QPen(HOUDINI_NODE_BORDER, 1.5))
        painter.setPen(self.pen())
        painter.setBrush(self.brush())
        painter.drawRect(self.rect())
    
    def get_all_ports(self):
        all_ports = []
        
        def collect_subports(subport):
            all_ports.append(subport)
            for nested_subport in subport.subport_widgets:
                collect_subports(nested_subport)
        
        for port in self.input_ports + self.output_ports:
            all_ports.append(port)
            for subport in port.subport_widgets:
                collect_subports(subport)
        
        return all_ports
    
    def to_dict(self):
        return {
            'type': self.node_type.name,
            'name': self.node_name,
            'x': self.pos().x(),
            'y': self.pos().y()
        }


class NodeEditorScene(QGraphicsScene):
    def __init__(self):
        super().__init__()
        self.temp_connection = None
        self.drag_start_port = None
        self.setBackgroundBrush(QBrush(HOUDINI_BG_DARK))
        self.setSceneRect(-10000, -10000, 20000, 20000)


class NodeEditorView(QGraphicsView):
    def __init__(self, registry):
        super().__init__()
        self.registry = registry
        self.editor_scene = NodeEditorScene()
        self.setScene(self.editor_scene)
        
        self.setRenderHint(QPainter.Antialiasing)
        self.setRenderHint(QPainter.SmoothPixmapTransform)
        self.setDragMode(QGraphicsView.RubberBandDrag)  # Enable rubber band selection
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        
        self.nodes = []
        self.connections = []
        self.last_mouse_pos = QPointF(0, 0)
        self.is_dragging_connection = False
        self.is_panning = False
        self.pan_start_pos = QPointF()
        self.drag_locked_ports = []
    
    def drawBackground(self, painter, rect):
        super().drawBackground(painter, rect)
        
        grid_size = 20
        left = int(rect.left()) - (int(rect.left()) % grid_size)
        top = int(rect.top()) - (int(rect.top()) % grid_size)
        
        fine_lines = []
        thick_lines = []
        
        x = left
        while x < rect.right():
            if x % 100 == 0:
                thick_lines.append((x, rect.top(), x, rect.bottom()))
            else:
                fine_lines.append((x, rect.top(), x, rect.bottom()))
            x += grid_size
        
        y = top
        while y < rect.bottom():
            if y % 100 == 0:
                thick_lines.append((rect.left(), y, rect.right(), y))
            else:
                fine_lines.append((rect.left(), y, rect.right(), y))
            y += grid_size
        
        painter.setPen(QPen(HOUDINI_GRID_FINE, 1))
        for line in fine_lines:
            painter.drawLine(line[0], line[1], line[2], line[3])
        
        painter.setPen(QPen(HOUDINI_GRID_THICK, 1))
        for line in thick_lines:
            painter.drawLine(line[0], line[1], line[2], line[3])
    
    def _lock_port_hierarchy(self, port):
        self.drag_locked_ports.append(port)
        
        if isinstance(port, SubportWidget):
            current = port.parent_port
            while current:
                self.drag_locked_ports.append(current)
                if hasattr(current, 'parent_port'):
                    current = current.parent_port
                else:
                    break
    
    def _unlock_all_ports(self):
        self.drag_locked_ports.clear()
    
    def _is_port_locked(self, port):
        return port in self.drag_locked_ports
    
    def contextMenuEvent(self, event):
        item = self.itemAt(event.pos())
        if item is None or isinstance(item, QGraphicsTextItem):
            self.show_node_creation_menu(event.pos())
        else:
            super().contextMenuEvent(event)
    
    def mousePressEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        self.last_mouse_pos = self.mapToScene(pos.toPoint())
        
        items = self.items(pos.toPoint())
        
        if event.button() == Qt.LeftButton:
            port_item = None
            for item in items:
                if isinstance(item, (PortWidget, SubportWidget)):
                    port_item = item
                    break
            
            if port_item:
                # Disable rubber band for port dragging
                self.setDragMode(QGraphicsView.NoDrag)
                self._lock_port_hierarchy(port_item)
                self.start_connection(port_item)
                self.is_dragging_connection = True
                event.accept()
                return
            else:
                # Enable rubber band for selection
                self.setDragMode(QGraphicsView.RubberBandDrag)
        
        elif event.button() == Qt.MiddleButton:
            self.setDragMode(QGraphicsView.NoDrag)
            self.is_panning = True
            self.pan_start_pos = pos
            self.setCursor(Qt.ClosedHandCursor)
            event.accept()
            return
        
        super().mousePressEvent(event)
    
    def mouseMoveEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        self.last_mouse_pos = self.mapToScene(pos.toPoint())
        
        if self.is_panning:
            delta = pos - self.pan_start_pos
            self.pan_start_pos = pos
            
            self.horizontalScrollBar().setValue(
                self.horizontalScrollBar().value() - int(delta.x())
            )
            self.verticalScrollBar().setValue(
                self.verticalScrollBar().value() - int(delta.y())
            )
            event.accept()
            return
        
        if self.is_dragging_connection and self.editor_scene.temp_connection:
            try:
                if not self.editor_scene.drag_start_port:
                    self.is_dragging_connection = False
                    self.setDragMode(QGraphicsView.RubberBandDrag)
                    return
                    
                start_pos = self.editor_scene.drag_start_port.get_scene_pos()
                end_pos = self.last_mouse_pos
                
                path = QPainterPath()
                path.moveTo(start_pos)
                
                is_input_drag = self.editor_scene.drag_start_port.is_input
                ctrl_offset = abs(end_pos.x() - start_pos.x()) * 0.5
                
                if is_input_drag:
                    ctrl1 = QPointF(start_pos.x() - ctrl_offset, start_pos.y())
                    ctrl2 = QPointF(end_pos.x() + ctrl_offset, end_pos.y())
                else:
                    ctrl1 = QPointF(start_pos.x() + ctrl_offset, start_pos.y())
                    ctrl2 = QPointF(end_pos.x() - ctrl_offset, end_pos.y())
                
                path.cubicTo(ctrl1, ctrl2, end_pos)
                
                self.editor_scene.temp_connection.setPath(path)
                
                items = self.items(pos.toPoint())
                for item in items:
                    if isinstance(item, (PortWidget, SubportWidget)):
                        if item.is_input and item.is_occupied():
                            break
                        if item.subport_defs and not item.expanded:
                            item.expand()
                        break
                
                event.accept()
                return
            except RuntimeError:
                self.is_dragging_connection = False
                if self.editor_scene.temp_connection:
                    self.editor_scene.removeItem(self.editor_scene.temp_connection)
                    self.editor_scene.temp_connection = None
                self.editor_scene.drag_start_port = None
                self._unlock_all_ports()
                self.setDragMode(QGraphicsView.RubberBandDrag)
                return
        
        super().mouseMoveEvent(event)
    
    def mouseReleaseEvent(self, event):
        pos = event.position() if hasattr(event, 'position') else event.pos()
        
        if event.button() == Qt.MiddleButton:
            self.is_panning = False
            self.setDragMode(QGraphicsView.RubberBandDrag)
            self.setCursor(Qt.ArrowCursor)
            event.accept()
            return
        
        if event.button() == Qt.LeftButton and self.is_dragging_connection:
            self.is_dragging_connection = False
            
            if self.editor_scene.temp_connection:
                items = self.items(pos.toPoint())
                
                target_port = None
                for item in items:
                    if isinstance(item, (PortWidget, SubportWidget)):
                        target_port = item
                        break
                
                if target_port and self.editor_scene.drag_start_port:
                    start_port = self.editor_scene.drag_start_port
                    
                    try:
                        _ = start_port.scene()
                        _ = target_port.scene()
                        
                        if start_port.is_connectable_to(target_port):
                            output_port = start_port if not start_port.is_input else target_port
                            input_port = target_port if target_port.is_input else start_port
                            
                            conn = Connection(output_port, input_port, self.editor_scene)
                            self.editor_scene.addItem(conn)
                            self.connections.append(conn)
                    except RuntimeError:
                        pass
                
                self.editor_scene.removeItem(self.editor_scene.temp_connection)
                self.editor_scene.temp_connection = None
                self.editor_scene.drag_start_port = None
            
            self._unlock_all_ports()
            self.setDragMode(QGraphicsView.RubberBandDrag)
            event.accept()
            return
        
        super().mouseReleaseEvent(event)
    
    def start_connection(self, port):
        self.editor_scene.drag_start_port = port
        self.editor_scene.temp_connection = QGraphicsPathItem()
        color = get_type_color(port.type_name)
        self.editor_scene.temp_connection.setPen(QPen(color, 2.5, Qt.DashLine))
        self.editor_scene.addItem(self.editor_scene.temp_connection)
    
    def show_node_creation_menu(self, view_pos):
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 25px 6px 15px;
                border-radius: 3px;
            }}
            QMenu::item:selected {{
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QMenu::separator {{
                height: 1px;
                background: {HOUDINI_NODE_BORDER.name()};
                margin: 4px 0px;
            }}
        """)
        
        scene_pos = self.mapToScene(view_pos)
        
        categories = {}
        for node_type_name in sorted(self.registry.node_types.keys()):
            if '_' in node_type_name:
                category = node_type_name.split('_')[0]
            else:
                category = "Other"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(node_type_name)
        
        for category in sorted(categories.keys()):
            if len(categories) > 1:
                submenu = menu.addMenu(category)
                submenu.setStyleSheet(menu.styleSheet())
            else:
                submenu = menu
            
            for node_type_name in sorted(categories[category]):
                action = submenu.addAction(node_type_name)
                action.triggered.connect(lambda checked=False, name=node_type_name, pos=scene_pos: 
                                       self.add_node(name, pos))
        
        menu.exec(self.mapToGlobal(view_pos))
    
    def show_node_type_menu(self, node, view_pos):
        """Show menu to change node type"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background-color: {HOUDINI_BG.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 25px 6px 15px;
                border-radius: 3px;
            }}
            QMenu::item:selected {{
                background-color: {HOUDINI_BG_LIGHT.name()};
            }}
            QMenu::separator {{
                height: 1px;
                background: {HOUDINI_NODE_BORDER.name()};
                margin: 4px 0px;
            }}
        """)
        
        categories = {}
        for node_type_name in sorted(self.registry.node_types.keys()):
            if '_' in node_type_name:
                category = node_type_name.split('_')[0]
            else:
                category = "Other"
            
            if category not in categories:
                categories[category] = []
            categories[category].append(node_type_name)
        
        for category in sorted(categories.keys()):
            if len(categories) > 1:
                submenu = menu.addMenu(category)
                submenu.setStyleSheet(menu.styleSheet())
            else:
                submenu = menu
            
            for node_type_name in sorted(categories[category]):
                action = submenu.addAction(node_type_name)
                action.triggered.connect(lambda checked=False, n=node, name=node_type_name: 
                                       n.change_type(name))
        
        menu.exec(self.mapToGlobal(view_pos))
    
    def add_node(self, node_type_name, pos):
        node_type = self.registry.get_node_type(node_type_name)
        if node_type:
            base_name = node_type.name
            counter = 1
            name = base_name
            existing_names = {node.node_name for node in self.nodes}
            while name in existing_names:
                name = f"{base_name}_{counter}"
                counter += 1
            
            node = NodeWidget(node_type, self.registry, name)
            node.setPos(pos)
            self.editor_scene.addItem(node)
            self.nodes.append(node)
            return node
    
    def delete_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                all_ports = item.get_all_ports()
                for port in all_ports:
                    for conn in port.connections[:]:
                        conn.remove()
                        if conn in self.connections:
                            self.connections.remove(conn)
                
                self.nodes.remove(item)
                self.editor_scene.removeItem(item)
            
            elif isinstance(item, Connection):
                item.remove()
                if item in self.connections:
                    self.connections.remove(item)
    
    def rename_selected(self):
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                text, ok = QInputDialog.getText(self, "Rename Node", 
                                               "New name:", QLineEdit.Normal,
                                               item.node_name)
                if ok and text:
                    item.node_name = text
                    item.header.setPlainText(text)
                break
    
    def change_type_selected(self):
        """Change the type of selected node"""
        selected = self.editor_scene.selectedItems()
        
        for item in selected:
            if isinstance(item, NodeWidget):
                view_pos = self.mapFromScene(item.pos())
                self.show_node_type_menu(item, view_pos)
                break
    
    def frame_all(self):
        if not self.nodes:
            return
        
        min_x = min(node.pos().x() for node in self.nodes)
        max_x = max(node.pos().x() + node.rect().width() for node in self.nodes)
        min_y = min(node.pos().y() for node in self.nodes)
        max_y = max(node.pos().y() + node.rect().height() for node in self.nodes)
        
        padding = 100
        min_x -= padding
        max_x += padding
        min_y -= padding
        max_y += padding
        
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        width = max_x - min_x
        height = max_y - min_y
        
        rect = QRectF(min_x, min_y, width, height)
        self.fitInView(rect, Qt.KeepAspectRatio)
        
        if self.transform().m11() > 2.0:
            self.resetTransform()
            self.scale(1.0, 1.0)
            self.centerOn(center_x, center_y)
    
    def save_to_json(self):
        nodes_data = []
        connections_data = []
        
        for node in self.nodes:
            nodes_data.append(node.to_dict())
        
        for conn in self.connections:
            connections_data.append({
                'output_node': conn.output_node.node_name if conn.output_node else None,
                'output_index_path': conn.output_index_path,
                'input_node': conn.input_node.node_name if conn.input_node else None,
                'input_index_path': conn.input_index_path,
                'output_relative_y': conn.output_relative_y,
                'input_relative_y': conn.input_relative_y
            })
        
        port_types_data = {}
        for type_name, port_type in self.registry.port_types.items():
            port_types_data[type_name] = {
                'subports': [{'name': name, 'type': type_} for name, type_ in port_type.subports]
            }
        
        node_types_data = []
        for node_type in self.registry.node_types.values():
            node_types_data.append({
                'name': node_type.name,
                'inputs': [{'name': name, 'type': type_} for name, type_ in node_type.inputs],
                'outputs': [{'name': name, 'type': type_} for name, type_ in node_type.outputs]
            })
        
        return {
            'port_types': port_types_data,
            'node_types': node_types_data,
            'nodes': nodes_data,
            'connections': connections_data
        }
    
    def load_from_json(self, data):
        if 'port_types' in data or 'node_types' in data:
            self.registry.load_from_json(data)
        
        for node in self.nodes[:]:
            all_ports = node.get_all_ports()
            for port in all_ports:
                for conn in port.connections[:]:
                    if conn in self.connections:
                        self.connections.remove(conn)
                    if conn.scene():
                        self.editor_scene.removeItem(conn)
            self.editor_scene.removeItem(node)
        self.nodes.clear()
        self.connections.clear()
        
        node_map = {}
        for node_data in data.get('nodes', []):
            node = self.add_node(node_data['type'], 
                               QPointF(node_data['x'], node_data['y']))
            if node:
                node.node_name = node_data['name']
                node.header.setPlainText(node_data['name'])
                node_map[node_data['name']] = node
        
        for conn_data in data.get('connections', []):
            output_node = node_map.get(conn_data['output_node'])
            input_node = node_map.get(conn_data['input_node'])
            output_index_path = conn_data.get('output_index_path', [])
            input_index_path = conn_data.get('input_index_path', [])
            
            if output_node or input_node:
                output_port = None
                input_port = None
                
                if output_node and output_index_path:
                    output_port = self._find_port_by_index(output_node, output_index_path, False)
                
                if input_node and input_index_path:
                    input_port = self._find_port_by_index(input_node, input_index_path, True)
                
                conn = Connection(output_port, input_port, self.editor_scene, 
                                output_index_path, input_index_path)
                conn.output_node = output_node
                conn.input_node = input_node
                conn.output_relative_y = conn_data.get('output_relative_y', 0)
                conn.input_relative_y = conn_data.get('input_relative_y', 0)
                conn.output_valid = output_port is not None
                conn.input_valid = input_port is not None
                
                self.editor_scene.addItem(conn)
                self.connections.append(conn)
    
    def _find_port_by_index(self, node, index_path, is_input):
        if not node or not index_path:
            return None
        
        ports = node.input_ports if is_input else node.output_ports
        
        if index_path[0] >= len(ports):
            return None
        
        current_port = ports[index_path[0]]
        
        for idx in index_path[1:]:
            if not current_port.expanded:
                current_port.expand()
            
            if idx >= len(current_port.subport_widgets):
                return None
            
            current_port = current_port.subport_widgets[idx]
        
        return current_port
    
    def expand_selected_connections(self):
        """Expand selected connections and select the newly created ones"""
        selected = self.editor_scene.selectedItems()
        
        new_connections = []
        for item in selected:
            if isinstance(item, Connection):
                expanded = item.expand_connection()
                new_connections.extend(expanded)
                # Add new connections to tracking list
                for conn in expanded:
                    if conn not in self.connections:
                        self.connections.append(conn)
                # Remove old connection from tracking
                if item in self.connections:
                    self.connections.remove(item)
        
        # Select all the newly created connections
        for conn in new_connections:
            conn.setSelected(True)
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete or event.key() == Qt.Key_Backspace:
            self.delete_selected()
        elif event.key() == Qt.Key_F2:
            self.rename_selected()
        elif event.key() == Qt.Key_M:
            self.change_type_selected()
        elif event.key() == Qt.Key_Tab:
            view_pos = self.mapFromScene(self.last_mouse_pos)
            self.show_node_creation_menu(view_pos)
        elif event.key() == Qt.Key_G:
            self.frame_all()
        elif event.key() == Qt.Key_E:
            self.expand_selected_connections()
        else:
            super().keyPressEvent(event)
    
    def wheelEvent(self, event):
        zoom_factor = 1.12
        if event.angleDelta().y() > 0:
            self.scale(zoom_factor, zoom_factor)
        else:
            self.scale(1 / zoom_factor, 1 / zoom_factor)


class NodeEditorWidget(QWidget):
    """Main widget for Houdini Python Pane"""
    def __init__(self):
        super().__init__()
        self.registry = NodeTypeRegistry()
        self._load_default_types()
        self._create_ui()
    
    def _load_default_types(self):
        default_config = {
            "port_types": {
                "Float": {"subports": []},
                "Vector3": {
                    "subports": [
                        {"name": "x", "type": "Float"},
                        {"name": "y", "type": "Float"},
                        {"name": "z", "type": "Float"}
                    ]
                },
                "Particle": {
                    "subports": [
                        {"name": "position", "type": "Vector3"},
                        {"name": "velocity", "type": "Vector3"}
                    ]
                }
            },
            "node_types": [
                {
                    "name": "Length",
                    "inputs": [{"name": "vector", "type": "Vector3"}],
                    "outputs": [{"name": "length", "type": "Float"}]
                },
                {
                    "name": "Add",
                    "inputs": [
                        {"name": "a", "type": "Vector3"},
                        {"name": "b", "type": "Vector3"}
                    ],
                    "outputs": [{"name": "result", "type": "Vector3"}]
                }
            ]
        }
        self.registry.load_from_json(default_config)
    
    def _create_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        toolbar_frame = QFrame()
        toolbar_frame.setStyleSheet(f"""
            QFrame {{
                background-color: {HOUDINI_BG.name()};
                border-bottom: 1px solid {HOUDINI_NODE_BORDER.name()};
            }}
            QPushButton {{
                background-color: {HOUDINI_BG_LIGHT.name()};
                color: {HOUDINI_TEXT.name()};
                border: 1px solid {HOUDINI_NODE_BORDER.name()};
                border-radius: 3px;
                padding: 4px 12px;
                font-size: 11px;
            }}
            QPushButton:hover {{
                background-color: {HOUDINI_BG_LIGHT.lighter(110).name()};
            }}
            QPushButton:pressed {{
                background-color: {HOUDINI_BG.name()};
            }}
            QLabel {{
                color: {HOUDINI_TEXT_DIM.name()};
                font-size: 10px;
                padding: 0 8px;
            }}
        """)
        
        toolbar_layout = QHBoxLayout(toolbar_frame)
        toolbar_layout.setContentsMargins(4, 4, 4, 4)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_graph)
        toolbar_layout.addWidget(save_btn)
        
        load_btn = QPushButton("Load")
        load_btn.clicked.connect(self.load_graph)
        toolbar_layout.addWidget(load_btn)
        
        toolbar_layout.addSpacing(8)
        
        save_to_node_btn = QPushButton("Save to Node")
        save_to_node_btn.clicked.connect(self.save_to_node)
        toolbar_layout.addWidget(save_to_node_btn)
        
        load_from_node_btn = QPushButton("Load from Node")
        load_from_node_btn.clicked.connect(self.load_from_node)
        toolbar_layout.addWidget(load_from_node_btn)
        
        toolbar_layout.addSpacing(8)
        
        load_types_btn = QPushButton("Load Types")
        load_types_btn.clicked.connect(self.load_node_types)
        toolbar_layout.addWidget(load_types_btn)
        
        toolbar_layout.addStretch()
        
        instructions = QLabel("Drag: select | RMB/Tab: add | M: change type | E: expand wire | Del: remove | F2: rename | G: frame")
        toolbar_layout.addWidget(instructions)
        
        layout.addWidget(toolbar_frame)
        
        self.editor = NodeEditorView(self.registry)
        layout.addWidget(self.editor)
        
        self.editor.centerOn(0, 0)
    
    def save_graph(self):
        filename, _ = QFileDialog.getSaveFileName(self, "Save Graph", "", "JSON Files (*.json)")
        if filename:
            data = self.editor.save_to_json()
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
    
    def load_graph(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Graph", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r') as f:
                data = json.load(f)
            self.editor.load_from_json(data)
    
    def load_node_types(self):
        filename, _ = QFileDialog.getOpenFileName(self, "Load Node Types", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r') as f:
                data = json.load(f)
            self.registry.load_from_json(data)
    
    def save_to_node(self):
        selected = hou.selectedNodes()
        if not selected:
            hou.ui.displayMessage("Please select a node first", severity=hou.severityType.Warning)
            return
        
        node = selected[0]
        
        if not node.parm('network'):
            parm_template = hou.StringParmTemplate('network', 'Network', 1, 
                                                   string_type=hou.stringParmType.Regular)
            parm_group = node.parmTemplateGroup()
            parm_group.append(parm_template)
            node.setParmTemplateGroup(parm_group)
        
        data = self.editor.save_to_json()
        json_str = json.dumps(data, indent=2)
        node.parm('network').set(json_str)
        
        hou.ui.displayMessage(f"Network saved to node: {node.path()}", severity=hou.severityType.Message)
    
    def load_from_node(self):
        selected = hou.selectedNodes()
        if not selected:
            hou.ui.displayMessage("Please select a node first", severity=hou.severityType.Warning)
            return
        
        node = selected[0]
        
        if not node.parm('network'):
            hou.ui.displayMessage("Selected node has no 'network' parameter", severity=hou.severityType.Warning)
            return
        
        json_str = node.parm('network').eval()
        if not json_str:
            hou.ui.displayMessage("Network parameter is empty", severity=hou.severityType.Warning)
            return
        
        try:
            data = json.loads(json_str)
            self.editor.load_from_json(data)
            hou.ui.displayMessage(f"Network loaded from node: {node.path()}", severity=hou.severityType.Message)
        except json.JSONDecodeError as e:
            hou.ui.displayMessage(f"Failed to parse network data: {e}", severity=hou.severityType.Error)


def createInterface():
    return NodeEditorWidget()
]]></script>
    <includeInPaneTabMenu menu_position="0" create_separator="false"/>
    <includeInToolbarMenu menu_position="208" create_separator="false"/>
    <help><![CDATA[]]></help>
  </interface>
</pythonPanelDocument>
